---
import Layout from "../../layouts/default.astro";
---

<Layout title="Hangul Hero - Korean Typing Game">
  <main class="container mx-auto px-4 py-8">
    <div class="max-w-2xl mx-auto">
      <div class="arcade-cabinet">
        <div class="cabinet-top">
          <div class="marquee">
            <div class="marquee-pattern"></div>
            <div class="marquee-decoration left">
              <div class="korean-chars">
                <div class="char-column">
                  <span style="color: #FF6B6B">ㄱ</span>
                  <span style="color: #4ECDC4">ㅏ</span>
                  <span style="color: #45B7D1">ㄴ</span>
                  <span style="color: #96CEB4">ㅗ</span>
                  <span style="color: #FFEEAD">ㄹ</span>
                  <span style="color: #D4A5A5">ㅎ</span>
                </div>
                <div class="char-column">
                  <span style="color: #45B7D1">ㅂ</span>
                  <span style="color: #FF6B6B">ㅓ</span>
                  <span style="color: #FFEEAD">ㅅ</span>
                  <span style="color: #4ECDC4">ㅜ</span>
                  <span style="color: #96CEB4">ㅈ</span>
                  <span style="color: #D4A5A5">ㅣ</span>
                </div>
                <div class="char-column">
                  <span style="color: #FF6B6B">ㅊ</span>
                  <span style="color: #4ECDC4">ㅑ</span>
                  <span style="color: #45B7D1">ㅋ</span>
                  <span style="color: #FFEEAD">ㅠ</span>
                  <span style="color: #96CEB4">ㅌ</span>
                  <span style="color: #D4A5A5">ㅡ</span>
                </div>
              </div>
            </div>
            <div class="marquee-decoration right">
              <div class="korean-chars">
                <div class="char-column">
                  <span style="color: #4ECDC4">ㅍ</span>
                  <span style="color: #FF6B6B">ㅕ</span>
                  <span style="color: #96CEB4">ㄷ</span>
                  <span style="color: #FFEEAD">ㅛ</span>
                  <span style="color: #45B7D1">ㅇ</span>
                  <span style="color: #D4A5A5">ㅐ</span>
                </div>
                <div class="char-column">
                  <span style="color: #FF6B6B">ㅁ</span>
                  <span style="color: #4ECDC4">ㅔ</span>
                  <span style="color: #D4A5A5">ㅃ</span>
                  <span style="color: #96CEB4">ㅒ</span>
                  <span style="color: #FFEEAD">ㄸ</span>
                  <span style="color: #45B7D1">ㅉ</span>
                </div>
                <div class="char-column">
                  <span style="color: #4ECDC4">ㄲ</span>
                  <span style="color: #FF6B6B">ㅖ</span>
                  <span style="color: #96CEB4">ㅆ</span>
                  <span style="color: #FFEEAD">ㅢ</span>
                  <span style="color: #45B7D1">ㅚ</span>
                  <span style="color: #D4A5A5">ㅟ</span>
                </div>
              </div>
            </div>
            <h1
              class="text-8xl font-bold text-center font-bangers tracking-wider marquee-title"
              style="text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;"
            >
              <span style="color: #FF6B6B">한</span><span style="color: #4ECDC4"
                >글</span
              >
              <span style="color: #45B7D1">H</span><span style="color: #96CEB4"
                >E</span
              ><span style="color: #FFEEAD">R</span><span style="color: #D4A5A5"
                >O</span
              >
            </h1>
          </div>
        </div>
        <div class="screen-bezel">
          <div class="screen-container">
            <div class="screen-overlay"></div>
            <div class="screen-content">
              <div id="game-container" class="game-screen">
                <input
                  type="text"
                  id="korean-input"
                  class="opacity-0 fixed -left-[9999px] -top-[9999px]"
                  autocomplete="off"
                  aria-hidden="true"
                />
              </div>
            </div>
          </div>
        </div>
        <div class="cabinet-bottom">
          <div class="control-panel">
            <div class="speaker-grill">
              <div class="speaker-pattern"></div>
            </div>
            <button id="start-button" class="arcade-start-button">
              <div class="button-surface">
                <div class="button-text">시작</div>
              </div>
              <div class="button-base"></div>
            </button>
          </div>
        </div>
      </div>
    </div>
  </main>
</Layout>

<style>
  :root {
    --cabinet-color: #c8b2b2;
    --button-color: #4ade80; /* Light green */
    --button-glow: rgba(74, 222, 128, 0.5);
    --button-color-active: #fbbf24; /* Amber/yellow */
    --button-glow-active: rgba(251, 191, 36, 0.5);
  }

  .arcade-cabinet {
    background: linear-gradient(
      45deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    padding: 2rem;
    border-radius: 1rem;
    box-shadow:
      0 0 0 4px color-mix(in srgb, var(--cabinet-color) 85%, black),
      0 0 0 8px color-mix(in srgb, var(--cabinet-color) 75%, black),
      0 10px 20px rgba(0, 0, 0, 0.5);
    border: 1px solid color-mix(in srgb, var(--cabinet-color) 65%, black);
  }

  .arcade-cabinet::before {
    display: none;
  }

  .cabinet-top {
    margin: -2rem -2rem 1rem -2rem;
    padding: 1.5rem;
    background: linear-gradient(
      180deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    border-radius: 1rem 1rem 0 0;
    border-bottom: 4px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
    box-shadow:
      inset 0 2px 5px rgba(255, 255, 255, 0.2),
      inset 0 -2px 5px rgba(0, 0, 0, 0.2);
  }

  .cabinet-bottom {
    margin: 1rem -2rem -2rem -2rem;
    padding: 1rem;
    background: linear-gradient(
      0deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    border-radius: 0 0 1rem 1rem;
    border-top: 4px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
  }

  .control-panel {
    background: linear-gradient(
      90deg,
      var(--cabinet-color),
      color-mix(in srgb, var(--cabinet-color) 85%, black),
      var(--cabinet-color)
    );
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow:
      inset 0 2px 8px rgba(255, 255, 255, 0.15),
      inset 0 -2px 8px rgba(0, 0, 0, 0.2),
      0 2px 4px rgba(0, 0, 0, 0.15);
    text-align: center;
    position: relative;
    min-height: 80px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem;
    border: 1px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
  }

  .speaker-grill {
    position: relative;
    width: 140px;
    height: 100px;
    background: linear-gradient(
      135deg,
      color-mix(in srgb, var(--cabinet-color) 95%, black) 0%,
      color-mix(in srgb, var(--cabinet-color) 85%, black) 50%,
      color-mix(in srgb, var(--cabinet-color) 98%, black) 100%
    );
    border-radius: 4px;
    box-shadow:
      inset 0 2px 8px rgba(0, 0, 0, 0.5),
      inset -2px -2px 6px rgba(0, 0, 0, 0.4),
      inset 2px 2px 6px rgba(255, 255, 255, 0.15),
      1px 1px 2px rgba(255, 255, 255, 0.1);
    overflow: hidden;
    margin: -1rem 0rem -1rem -1.5rem;
    border-radius: 0.5rem 50% 50% 0.5rem;
    border: 1px solid color-mix(in srgb, var(--cabinet-color) 65%, black);
  }

  .speaker-pattern {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: radial-gradient(
        circle at center,
        rgba(0, 0, 0, 0.7) 0,
        rgba(0, 0, 0, 0.7) 1.5px,
        transparent 1.5px
      ),
      linear-gradient(
        135deg,
        transparent 0%,
        rgba(0, 0, 0, 0.15) 50%,
        transparent 100%
      );
    background-size:
      6px 6px,
      100% 100%;
    background-position:
      2px 2px,
      0 0;
    opacity: 0.85;
  }

  .speaker-inner {
    display: none;
  }

  .arcade-start-button {
    position: relative;
    width: 80px;
    height: 60px;
    border: none;
    background: none;
    cursor: pointer;
    outline: none;
    padding: 0;
    transform-style: preserve-3d;
    transform: translateZ(0);
    transition: transform 0.1s;
  }

  .arcade-start-button:active {
    transform: translateY(3px);
  }

  .arcade-start-button:active .button-surface {
    transform: translateY(-1px);
    box-shadow:
      0 0 15px var(--button-glow),
      0 0 30px var(--button-glow),
      0 0 45px var(--button-glow),
      inset 0 0 8px rgba(255, 255, 255, 0.5);
  }

  .arcade-start-button .button-surface {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(
      circle at 30% 30%,
      color-mix(in srgb, var(--button-color) 85%, white),
      var(--button-color) 60%,
      color-mix(in srgb, var(--button-color) 85%, black)
    );
    border-radius: 8px;
    transform: translateY(-4px);
    transition:
      transform 0.1s,
      box-shadow 0.1s,
      background 0.3s;
    box-shadow:
      0 0 20px var(--button-glow),
      0 0 40px var(--button-glow),
      0 0 60px var(--button-glow),
      inset 0 0 15px rgba(255, 255, 255, 0.8),
      inset 2px 2px 2px rgba(255, 255, 255, 0.5),
      inset -2px -2px 2px rgba(0, 0, 0, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
  }

  .button-base {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: color-mix(in srgb, var(--button-color) 85%, black);
    border-radius: 8px;
    z-index: 1;
    box-shadow:
      inset 0 0 2px rgba(0, 0, 0, 0.5),
      0 2px 4px rgba(0, 0, 0, 0.3);
    transition: background 0.3s;
  }

  .button-text {
    color: white;
    font-family: Arial, sans-serif;
    font-size: 32px;
    font-weight: 800;
    text-shadow:
      0 0 5px rgba(255, 255, 255, 0.8),
      0 0 10px rgba(255, 255, 255, 0.5);
    transform: translateY(-1px);
  }

  .marquee {
    position: relative;
    background: linear-gradient(90deg, #ff3366, #ff6633);
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow:
      inset 0 0 20px rgba(255, 255, 255, 0.5),
      inset 0 0 40px rgba(255, 255, 255, 0.2),
      0 2px 4px rgba(0, 0, 0, 0.3);
    text-align: center;
    overflow: hidden;
    border: 2px solid #333;
  }

  .marquee::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: radial-gradient(
        circle at 50% 50%,
        rgba(255, 255, 255, 0.2) 0%,
        transparent 60%
      ),
      linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.1) 0%,
        rgba(255, 255, 255, 0.2) 25%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0.2) 75%,
        rgba(255, 255, 255, 0.1) 100%
      );
    animation: shine 3s linear infinite;
  }

  .marquee-decoration {
    position: absolute;
    top: 50%;
    width: 160px;
    transform: translateY(-50%);
  }

  .marquee-decoration.left {
    left: 0;
  }

  .marquee-decoration.right {
    right: 0;
  }

  .korean-chars {
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  .char-column {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }

  .korean-chars span {
    font-size: 20px;
    font-weight: bold;
    text-shadow:
      0 0 5px currentColor,
      0 0 10px currentColor,
      0 0 15px currentColor;
  }

  .marquee-pattern {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 25% 50%, #fff 1px, transparent 1px),
      radial-gradient(circle at 75% 50%, #fff 1px, transparent 1px);
    background-size: 40px 40px;
    opacity: 0.1;
    animation: twinkle 2s ease-in-out infinite alternate;
  }

  @keyframes shine {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }

  @keyframes twinkle {
    from {
      opacity: 0.05;
    }
    to {
      opacity: 0.15;
    }
  }

  .marquee-title {
    position: relative;
    z-index: 1;
    margin: 0;
    padding: 0.5rem;
    background: linear-gradient(
      90deg,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0.1) 20%,
      rgba(255, 255, 255, 0.1) 80%,
      rgba(255, 255, 255, 0) 100%
    );
    animation: title-shine 3s ease-in-out infinite;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
  }

  @keyframes title-shine {
    0%,
    100% {
      background-position: -200% center;
    }
    50% {
      background-position: 200% center;
    }
  }

  .screen-bezel {
    background: linear-gradient(45deg, #111, #333);
    padding: 1rem;
    border-radius: 1rem;
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.3);
    border: 2px solid #444;
  }

  .screen-container {
    position: relative;
    background: #000;
    border-radius: 0.5rem;
    overflow: hidden;
    border: 2px solid #1a1a1a;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  }

  .screen-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        rgba(18, 16, 16, 0) 50%,
        rgba(0, 0, 0, 0.25) 50%
      ),
      linear-gradient(
        90deg,
        rgba(255, 0, 0, 0.06),
        rgba(0, 255, 0, 0.02),
        rgba(0, 0, 255, 0.06)
      );
    background-size:
      100% 2px,
      3px 100%;
    pointer-events: none;
    z-index: 10;
    border-radius: 0.5rem;
  }

  .screen-content {
    position: relative;
    z-index: 1;
    background: #000;
    animation: flicker 0.15s infinite;
  }

  .game-screen {
    background: #000;
    position: relative;
    overflow: hidden;
    min-height: 400px;
  }

  #game-container canvas {
    border-radius: 0;
    display: block;
  }

  @keyframes flicker {
    0% {
      opacity: 0.97;
    }
    5% {
      opacity: 0.95;
    }
    10% {
      opacity: 0.9;
    }
    15% {
      opacity: 0.95;
    }
    20% {
      opacity: 0.98;
    }
    25% {
      opacity: 0.95;
    }
    30% {
      opacity: 0.9;
    }
    35% {
      opacity: 0.95;
    }
    40% {
      opacity: 0.98;
    }
    45% {
      opacity: 0.95;
    }
    50% {
      opacity: 0.9;
    }
    55% {
      opacity: 0.95;
    }
    60% {
      opacity: 0.98;
    }
    65% {
      opacity: 0.95;
    }
    70% {
      opacity: 0.9;
    }
    75% {
      opacity: 0.95;
    }
    80% {
      opacity: 0.98;
    }
    85% {
      opacity: 0.95;
    }
    90% {
      opacity: 0.9;
    }
    95% {
      opacity: 0.95;
    }
    100% {
      opacity: 0.98;
    }
  }

  .arcade-start-button.active .button-surface {
    background: radial-gradient(
      circle at 30% 30%,
      color-mix(in srgb, var(--button-color-active) 85%, white),
      var(--button-color-active) 60%,
      color-mix(in srgb, var(--button-color-active) 85%, black)
    );
    box-shadow:
      0 0 20px var(--button-glow-active),
      0 0 40px var(--button-glow-active),
      0 0 60px var(--button-glow-active),
      inset 0 0 15px rgba(255, 255, 255, 0.8),
      inset 2px 2px 2px rgba(255, 255, 255, 0.5),
      inset -2px -2px 2px rgba(0, 0, 0, 0.3);
  }

  .arcade-start-button.active:active .button-surface {
    box-shadow:
      0 0 15px var(--button-glow-active),
      0 0 30px var(--button-glow-active),
      0 0 45px var(--button-glow-active),
      inset 0 0 8px rgba(255, 255, 255, 0.5);
  }

  .arcade-start-button.active .button-base {
    background: color-mix(in srgb, var(--button-color-active) 85%, black);
  }
</style>

<script>
  import p5 from "p5";

  // Basic Hangul characters (consonants and vowels)
  const HANGUL_CHARS = [
    "ㄱ",
    "ㄴ",
    "ㄷ",
    "ㄹ",
    "ㅁ",
    "ㅂ",
    "ㅅ",
    "ㅇ",
    "ㅈ",
    "ㅊ",
    "ㅋ",
    "ㅌ",
    "ㅍ",
    "ㅎ",
    "ㅏ",
    "ㅑ",
    "ㅓ",
    "ㅕ",
    "ㅗ",
    "ㅛ",
    "ㅜ",
    "ㅠ",
    "ㅡ",
    "ㅣ",
  ];

  // Helper function to check if a character is Hangul
  function isHangul(char: string): boolean {
    return /[\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]/.test(char);
  }

  class FallingChar {
    x: number;
    y: number;
    char: string;
    speed: number;
    isBackground: boolean;
    color: string;
    size: number;
    opacity: number;
    toDelete: boolean;
    koreanPixelFont: p5.Font;

    constructor(
      x: number,
      char: string,
      speed: number,
      koreanPixelFont: p5.Font,
      isBackground = false
    ) {
      this.x = x;
      this.y = -30;
      this.char = char;
      this.speed = speed;
      this.isBackground = isBackground;
      this.color = isBackground ? this.getRandomColor() : "#FFFFFF";
      this.size = isBackground ? 20 : 24;
      this.opacity = isBackground ? 0.3 : 1;
      this.toDelete = false;
      this.koreanPixelFont = koreanPixelFont;
    }

    getRandomColor(): string {
      const colors = [
        "#00ff00", // Neon green
        "#ff0066", // Hot pink
        "#00ffff", // Cyan
        "#ffff00", // Yellow
        "#ff3399", // Pink
        "#33ccff", // Light blue
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    update(): void {
      this.y += this.speed;
    }

    draw(p: p5): void {
      p.push();
      p.textSize(this.size);
      p.textAlign(p.CENTER, p.CENTER);
      p.textStyle(p.BOLD);
      p.textFont(this.koreanPixelFont);

      // Draw outer glow
      if (!this.isBackground) {
        const glowColor = p.color(this.color);
        glowColor.setAlpha(this.opacity * 80);
        p.fill(glowColor);
        p.textSize(this.size + 4);
        p.text(this.char, this.x, this.y);

        // Draw middle glow
        glowColor.setAlpha(this.opacity * 120);
        p.fill(glowColor);
        p.textSize(this.size + 2);
        p.text(this.char, this.x, this.y);
      }

      // Draw main character
      const c = p.color(this.color);
      c.setAlpha(this.opacity * 255);
      p.fill(c);
      p.textSize(this.size);
      p.noStroke();
      p.text(this.char, this.x, this.y);

      // Draw inner highlight
      if (!this.isBackground) {
        const highlightColor = p.color("#ffffff");
        highlightColor.setAlpha(this.opacity * 180);
        p.fill(highlightColor);
        p.textSize(this.size * 0.9);
        p.text(this.char, this.x, this.y);
      }
      p.pop();
    }
  }

  class Game {
    private p: p5;
    public isPlaying: boolean;
    public isPaused: boolean;
    private score: number;
    private lives: number;
    private fallingChars: FallingChar[];
    private backgroundChars: FallingChar[];
    private speed: number;
    private lastTypedChar: string | null;
    private lastTypedCharColor: string;
    private lastTypedCharTime: number;
    private startTextOpacity: number;
    private startTextFading: number;
    public columnWidth: number;
    public numColumns: number;
    private minBackgroundSpacing: number;
    private columnLastY: number[];
    private gameStartTime: number;
    private lastSpawnTime: number;
    private initialSpawnInterval: number;
    private minSpawnInterval: number;
    private maxActiveChars: number;
    private initialSpeed: number;
    private maxSpeed: number;
    private pauseTextOpacity: number;
    private pauseTextFading: number;
    private pixelFont: p5.Font;
    private koreanPixelFont: p5.Font;

    constructor(p: p5, pixelFont: p5.Font, koreanPixelFont: p5.Font) {
      this.p = p;
      this.pixelFont = pixelFont;
      this.koreanPixelFont = koreanPixelFont;
      this.isPlaying = false;
      this.isPaused = false;
      this.score = 0;
      this.lives = 3;
      this.fallingChars = [];
      this.backgroundChars = [];
      this.speed = 1; // Reduced initial speed
      this.lastTypedChar = null;
      this.lastTypedCharColor = "#FFFFFF";
      this.lastTypedCharTime = 0;
      this.columnWidth = 40;
      this.numColumns = 0;
      this.startTextOpacity = 0;
      this.startTextFading = 1;
      this.minBackgroundSpacing = 60;
      this.columnLastY = [];
      this.gameStartTime = 0;
      this.lastSpawnTime = 0;
      this.initialSpawnInterval = 3000; // Start with 3 seconds between spawns
      this.minSpawnInterval = 500; // Minimum 0.5 seconds between spawns
      this.maxActiveChars = 1; // Start with max 1 character
      this.initialSpeed = 1;
      this.maxSpeed = 4;
      this.pauseTextOpacity = 0.3;
      this.pauseTextFading = 1;
    }

    setupInput(): void {
      const input = document.getElementById("korean-input") as HTMLInputElement;
      if (!input) return;

      // Add space bar handler for pause
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && this.isPlaying) {
          e.preventDefault(); // Prevent space from triggering input
          this.togglePause();
        }
      });

      // Focus input when game container is clicked
      const container = document.getElementById("game-container");
      if (container) {
        container.addEventListener("click", () => {
          input.focus();
        });
      }

      // Handle input events
      input.addEventListener("input", (e) => {
        if (!this.isPlaying || this.isPaused) return; // Don't process input when paused

        const char = (e.target as HTMLInputElement).value;
        if (char) {
          this.handleKeyPress(char);
          // Clear the input for the next character
          (e.target as HTMLInputElement).value = "";
        }
      });

      // Keep input focused when typing
      input.addEventListener("blur", () => {
        if (this.isPlaying && !this.isPaused) {
          input.focus();
        }
      });
    }

    togglePause(): void {
      this.isPaused = !this.isPaused;
      const input = document.getElementById("korean-input") as HTMLInputElement;
      const startButton = document.getElementById("start-button");
      if (this.isPaused) {
        input?.blur(); // Remove focus from input when paused
        startButton?.classList.remove("active");
      } else {
        input?.focus(); // Restore focus when unpaused
        startButton?.classList.add("active");
      }
    }

    start(): void {
      if (this.isPlaying) return;

      this.isPlaying = true;
      this.isPaused = false;
      this.score = 0;
      this.lives = 3;
      this.fallingChars = [];
      this.speed = this.initialSpeed;
      this.columnLastY = new Array(this.numColumns).fill(
        -this.minBackgroundSpacing
      );
      this.gameStartTime = this.p.millis();
      this.lastSpawnTime = this.gameStartTime;

      // Focus the input when game starts
      const input = document.getElementById("korean-input") as HTMLInputElement;
      const startButton = document.getElementById("start-button");
      if (input) {
        input.focus();
      }
      if (startButton) {
        startButton.classList.add("active");
      }
    }

    gameOver(): void {
      this.isPlaying = false;
      this.isPaused = false;
      this.fallingChars = [];
      this.lastTypedChar = null;
      const startButton = document.getElementById("start-button");
      if (startButton) {
        startButton.classList.remove("active");
      }
    }

    private calculateDifficulty(): void {
      const gameTime = this.p.millis() - this.gameStartTime;
      const minutes = gameTime / 60000; // Convert to minutes

      // Gradually increase speed based on time
      this.speed = Math.min(this.maxSpeed, this.initialSpeed + minutes * 0.5);

      // Gradually increase max active characters
      this.maxActiveChars = Math.min(5, 1 + Math.floor(minutes));

      // Calculate current spawn interval
      const spawnIntervalDecrease = Math.min(
        this.initialSpawnInterval - this.minSpawnInterval,
        minutes * 500
      );
      this.initialSpawnInterval = Math.max(
        this.initialSpawnInterval - spawnIntervalDecrease,
        this.minSpawnInterval
      );
    }

    update(): void {
      // Update start text opacity for pulsing effect
      this.startTextOpacity += 0.05 * this.startTextFading;
      if (this.startTextOpacity >= 1) {
        this.startTextFading = -1;
      } else if (this.startTextOpacity <= 0.3) {
        this.startTextFading = 1;
      }

      // Update pause text opacity for flashing effect
      if (this.isPaused) {
        this.pauseTextOpacity += 0.03 * this.pauseTextFading;
        if (this.pauseTextOpacity >= 1) {
          this.pauseTextFading = -1;
        } else if (this.pauseTextOpacity <= 0.3) {
          this.pauseTextFading = 1;
        }
      }

      // Don't update game state if paused
      if (this.isPaused) return;

      if (this.isPlaying) {
        this.calculateDifficulty();

        // Add new falling characters based on current difficulty
        const currentTime = this.p.millis();
        if (
          this.fallingChars.length < this.maxActiveChars &&
          currentTime - this.lastSpawnTime >= this.initialSpawnInterval
        ) {
          const char =
            HANGUL_CHARS[Math.floor(this.p.random(HANGUL_CHARS.length))];
          const column = Math.floor(this.p.random(this.numColumns));
          const x = column * this.columnWidth + this.columnWidth / 2;
          this.fallingChars.push(
            new FallingChar(x, char, this.speed, this.koreanPixelFont)
          );
          this.lastSpawnTime = currentTime;
        }

        // Update and filter falling characters
        this.fallingChars = this.fallingChars.filter((char) => {
          char.update();
          if (char.y >= this.p.height) {
            if (!char.isBackground) {
              this.lives--;
              if (this.lives <= 0) {
                this.gameOver();
              }
            }
            return false;
          }
          return true;
        });
      }

      // Background characters
      // Initialize column tracking if not already done
      if (this.columnLastY.length !== this.numColumns) {
        this.columnLastY = new Array(this.numColumns).fill(
          -this.minBackgroundSpacing
        );
      }

      // Add new background characters with spacing check
      for (let col = 0; col < this.numColumns; col++) {
        if (this.p.random(1) < 0.01) {
          // Check if there's enough space in this column
          const lastY = this.columnLastY[col];
          const existingCharsInColumn = this.backgroundChars.filter(
            (char) =>
              Math.abs(
                char.x - (col * this.columnWidth + this.columnWidth / 2)
              ) < 1
          );

          const nearestCharY = existingCharsInColumn.reduce((nearest, char) => {
            return char.y < 0 && char.y > nearest ? char.y : nearest;
          }, -Infinity);

          if (
            nearestCharY === -Infinity ||
            nearestCharY < -this.minBackgroundSpacing
          ) {
            const char =
              HANGUL_CHARS[Math.floor(this.p.random(HANGUL_CHARS.length))];
            const x = col * this.columnWidth + this.columnWidth / 2;
            this.backgroundChars.push(
              new FallingChar(x, char, 0.5, this.koreanPixelFont, true)
            );
            this.columnLastY[col] = -30; // Update last Y position for this column
          }
        }
      }

      // Update background characters and their column positions
      this.backgroundChars = this.backgroundChars.filter((char) => {
        char.update();
        // Update column tracking
        const col = Math.floor(char.x / this.columnWidth);
        if (col >= 0 && col < this.numColumns) {
          this.columnLastY[col] = Math.max(this.columnLastY[col], char.y);
        }
        return char.y < this.p.height;
      });
    }

    private drawPixelHeart(x: number, y: number, filled: boolean): void {
      const size = 4; // Size of each pixel
      const heartPixels = [
        [0, 1, 0, 1, 0],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [0, 1, 1, 1, 0],
        [0, 0, 1, 0, 0],
      ];

      // Helper function to check if a pixel is on the edge
      const isEdgePixel = (i: number, j: number): boolean => {
        if (heartPixels[i][j] === 0) return false;

        // A pixel is an edge if it's a filled pixel (1) and it's either:
        // 1. On the outer border of the array
        // 2. Has at least one adjacent empty pixel (0)
        const isOuterBorder =
          i === 0 ||
          i === heartPixels.length - 1 ||
          j === 0 ||
          j === heartPixels[0].length - 1;

        if (isOuterBorder) return true;

        // Check orthogonal neighbors only (not diagonals)
        const neighbors = [
          [i - 1, j], // up
          [i + 1, j], // down
          [i, j - 1], // left
          [i, j + 1], // right
        ];

        return neighbors.some(
          ([ni, nj]) =>
            ni >= 0 &&
            ni < heartPixels.length &&
            nj >= 0 &&
            nj < heartPixels[0].length &&
            heartPixels[ni][nj] === 0
        );
      };

      this.p.push();
      this.p.noStroke();

      if (filled) {
        // Draw red fill for all non-edge pixels
        this.p.fill(255, 99, 107, 255); // #FF636B solid pink/red
        heartPixels.forEach((row, i) => {
          row.forEach((pixel, j) => {
            if (pixel === 1 && !isEdgePixel(i, j)) {
              this.p.rect(x + j * size, y + i * size, size, size);
            }
          });
        });
      }

      // Draw white pixels for the outline
      heartPixels.forEach((row, i) => {
        row.forEach((pixel, j) => {
          if (isEdgePixel(i, j)) {
            this.p.fill(255, 255, 255, 255);
            this.p.rect(x + j * size, y + i * size, size, size);
          }
        });
      });

      this.p.pop();
    }

    draw(): void {
      this.p.background(0);

      // Create CRT-style radial background
      const centerX = this.p.width / 2;
      const centerY = this.p.height / 2;
      const maxDist = Math.sqrt(
        Math.pow(this.p.width / 2, 2) + Math.pow(this.p.height / 2, 2)
      );

      for (let i = 0; i < 4; i++) {
        const gradient = this.p.drawingContext.createRadialGradient(
          centerX,
          centerY,
          0,
          centerX,
          centerY,
          maxDist * (1.4 - i * 0.15)
        );

        if (i === 0) {
          gradient.addColorStop(0, "rgba(96, 0, 192, 0.25)");
          gradient.addColorStop(0.85, "rgba(32, 0, 64, 0.15)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 0.3)");
        } else {
          gradient.addColorStop(0, "rgba(96, 0, 192, 0.06)");
          gradient.addColorStop(0.85, "rgba(32, 0, 64, 0.03)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 0.08)");
        }

        this.p.drawingContext.fillStyle = gradient;
        this.p.noStroke();

        // Create bulge effect by using ellipse with larger bulge
        const bulgeAmount = 1.2 - i * 0.015;
        this.p.ellipse(
          centerX,
          centerY,
          this.p.width * bulgeAmount,
          this.p.height * bulgeAmount
        );
      }

      // Draw background characters
      this.backgroundChars.forEach((char) => char.draw(this.p));

      // Draw falling characters
      this.fallingChars.forEach((char) => char.draw(this.p));

      // Draw score and lives
      if (this.isPlaying) {
        this.p.push();
        this.p.textFont(this.pixelFont);

        // Draw score on bottom left
        this.p.textAlign(this.p.LEFT, this.p.BOTTOM);
        this.p.textSize(16);

        // Score outer glow
        this.p.fill(150, 206, 180, 100); // #96CEB4 with alpha
        this.p.text(`SCORE ${this.score}`, 25, this.p.height - 20);

        // Score middle glow
        this.p.fill(150, 206, 180, 150); // #96CEB4 with alpha
        this.p.text(`SCORE ${this.score}`, 25, this.p.height - 20);

        // Score inner text
        this.p.fill(150, 206, 180, 255); // #96CEB4
        this.p.text(`SCORE ${this.score}`, 25, this.p.height - 20);

        // Draw hearts for lives
        const heartSpacing = 35;
        const startX = this.p.width - 20 - heartSpacing * 2;
        const startY = this.p.height - 30;

        for (let i = 0; i < 3; i++) {
          this.drawPixelHeart(
            startX + i * heartSpacing,
            startY,
            i < this.lives
          );
        }

        this.p.pop();

        // Draw pause overlay if paused
        if (this.isPlaying && this.isPaused) {
          this.p.push();

          // Semi-transparent background
          this.p.fill(0, 0, 0, 100);
          this.p.rect(0, 0, this.p.width, this.p.height);

          // Draw pause text in Korean with colors and wave effect
          this.p.textAlign(this.p.CENTER, this.p.CENTER);
          this.p.textSize(60);
          this.p.textFont(this.koreanPixelFont); // Use koreanPixelFont for Korean pause text
          this.p.textStyle(this.p.BOLD);

          const pauseText = "일시정지";
          const colors = [
            "#FF6B6B", // Pink/Red
            "#4ECDC4", // Teal
            "#45B7D1", // Light Blue
            "#96CEB4", // Sage
          ];

          // Calculate total width of text for centering
          const totalWidth = pauseText
            .split("")
            .reduce((width, char) => width + this.p.textWidth(char), 0);
          let currentX = this.p.width / 2 - totalWidth / 2 + 20;

          // Draw each character with animation
          pauseText.split("").forEach((char, i) => {
            const color = colors[i % colors.length];
            const yOffset = Math.sin(this.p.millis() / 600 + i * 0.5) * 20;

            // Outer glow
            const rgb = this.p.color(color);
            this.p.fill(color + "99"); // Reduce to 60% alpha
            for (let offset = 3; offset >= 1; offset--) {
              this.p.text(char, currentX, this.p.height / 2 + yOffset - offset);
              this.p.text(char, currentX, this.p.height / 2 + yOffset + offset);
              this.p.text(char, currentX - offset, this.p.height / 2 + yOffset);
              this.p.text(char, currentX + offset, this.p.height / 2 + yOffset);
            }

            // Main character
            this.p.fill(255, 255, 255);
            this.p.text(char, currentX, this.p.height / 2 + yOffset);
            this.p.fill(color + "FF");
            this.p.text(char, currentX, this.p.height / 2 + yOffset);

            currentX += this.p.textWidth(char) + 5; // Add small spacing between characters
          });

          // Subtitle with flashing effect and special glow for button text
          this.p.textSize(20);
          this.p.textFont(this.pixelFont);
          this.p.textAlign(this.p.CENTER, this.p.CENTER);

          const pressText = "PRESS ";
          const buttonText = "시작";
          const toResumeText = " TO RESUME";

          // Calculate total width for centering
          const resumeTextWidth = this.p.textWidth(
            pressText + buttonText + toResumeText
          );
          const startX = this.p.width / 2 - resumeTextWidth / 2;

          this.p.textAlign(this.p.LEFT, this.p.CENTER);

          // Increased spacing by moving the subtitle down a bit more
          const subtitleY = this.p.height / 2 + 80; // Increased from 60 to 80

          // Draw "PRESS" with normal opacity
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 255);
          this.p.text(pressText, startX, subtitleY);

          // Draw button text with arcade button glow effect
          const buttonX = startX + this.p.textWidth(pressText);

          // Use Arial for Korean button text
          this.p.textFont("Arial");
          this.p.textStyle(this.p.BOLD);

          // Calculate button dimensions
          const buttonPadding = 10;
          const buttonHeight = 30;
          const buttonWidth = this.p.textWidth(buttonText) + buttonPadding * 2;
          const buttonY = subtitleY - buttonHeight / 2;

          // Draw button base (shadow)
          this.p.fill(44, 132, 76, this.pauseTextOpacity * 255); // Darker green
          this.p.noStroke();
          this.p.rect(buttonX, buttonY + 4, buttonWidth, buttonHeight, 6);

          // Draw button surface
          this.p.fill(74, 222, 128, this.pauseTextOpacity * 255); // Light green
          this.p.rect(buttonX, buttonY, buttonWidth, buttonHeight, 6);

          // Add highlight to button
          const gradientHeight = buttonHeight * 0.4;
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 40);
          this.p.rect(
            buttonX,
            buttonY,
            buttonWidth,
            gradientHeight,
            6,
            6,
            0,
            0
          );

          // Outer button glow
          this.p.fill(74, 222, 128, this.pauseTextOpacity * 80); // Light green glow
          for (let offset = 2; offset >= 1; offset--) {
            this.p.text(
              buttonText,
              buttonX + buttonPadding - offset,
              buttonY + buttonHeight / 2 + 4 - offset
            );
            this.p.text(
              buttonText,
              buttonX + buttonPadding + offset,
              buttonY + buttonHeight / 2 + 4 + offset
            );
          }

          // Inner button text
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 255);
          this.p.text(
            buttonText,
            buttonX + buttonPadding,
            buttonY + buttonHeight / 2
          );

          // Draw "TO RESUME" with normal opacity
          this.p.textFont(this.pixelFont);
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 255);
          this.p.text(toResumeText, buttonX + buttonWidth + 5, subtitleY);

          this.p.pop();
        }
      }

      // Draw start/game over text
      if (!this.isPlaying) {
        this.p.push();
        this.p.textAlign(this.p.CENTER, this.p.CENTER);

        // Draw title text with wave animation
        const titleText = this.lives <= 0 ? "GAME OVER" : "한글 HERO";
        const colors = [
          "#FF6B6B", // Pink/Red
          "#4ECDC4", // Teal
          "#45B7D1", // Light Blue
          "#96CEB4", // Sage
          "#FFEEAD", // Light Yellow
          "#D4A5A5", // Light Pink
        ];

        if (this.lives <= 0) {
          // Game Over text
          this.p.textSize(40);
          this.p.textFont(this.pixelFont);

          // Draw text glow
          const glowColor = this.p.color("#ff0066");
          glowColor.setAlpha(this.startTextOpacity * 100);
          this.p.fill(glowColor);
          this.p.textSize(42);
          this.p.text(titleText, this.p.width / 2, this.p.height / 2 - 20);

          // Draw main text
          this.p.fill(255, 255, 255, this.startTextOpacity * 255);
          this.p.textSize(40);
          this.p.text(titleText, this.p.width / 2, this.p.height / 2 - 20);
        } else {
          // 한글 HERO title with wave animation
          this.p.textSize(60);

          // Calculate total width for centering
          const chars = titleText.split("");
          let totalWidth = 0;
          chars.forEach((char) => {
            if (isHangul(char)) {
              this.p.textFont("Arial");
            } else {
              this.p.textFont(this.pixelFont);
            }
            totalWidth += this.p.textWidth(char) + 5; // Account for spacing in width calculation
          });

          let currentX = this.p.width / 2 - totalWidth / 2;

          // Draw each character with animation
          chars.forEach((char, i) => {
            const color = colors[i % colors.length];
            const yOffset = Math.sin(this.p.millis() / 600 + i * 0.5) * 20;
            const xOffset = isHangul(char) ? 60 : 26;

            if (isHangul(char)) {
              this.p.textFont("Arial");
            } else {
              this.p.textFont(this.pixelFont);
            }

            // Outer glow
            this.p.fill(color + "99");
            for (let offset = 3; offset >= 1; offset--) {
              this.p.text(
                char,
                currentX + xOffset,
                this.p.height / 2 - 20 + yOffset - offset
              );
              this.p.text(
                char,
                currentX + xOffset,
                this.p.height / 2 - 20 + yOffset + offset
              );
              this.p.text(
                char,
                currentX + xOffset - offset,
                this.p.height / 2 - 20 + yOffset
              );
              this.p.text(
                char,
                currentX + xOffset + offset,
                this.p.height / 2 - 20 + yOffset
              );
            }

            // Main character
            this.p.fill(255, 255, 255);
            this.p.text(
              char,
              currentX + xOffset,
              this.p.height / 2 - 20 + yOffset
            );
            this.p.fill(color + "FF");
            this.p.text(
              char,
              currentX + xOffset,
              this.p.height / 2 - 20 + yOffset
            );

            currentX += this.p.textWidth(char) + 5; // Add small spacing between characters
          });
        }

        // Draw subtitle with button reference
        this.p.textSize(20);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);

        const pressText = "PRESS ";
        const buttonText = "시작";
        const toStartText = this.lives <= 0 ? " TO RESTART" : " TO START";

        // Calculate total width for centering
        const startTextWidth = this.p.textWidth(
          pressText + buttonText + toStartText
        );
        const startX = this.p.width / 2 - startTextWidth / 2;

        this.p.textAlign(this.p.LEFT, this.p.CENTER);

        // Draw "PRESS" with normal opacity
        this.p.fill(255, 255, 255, this.startTextOpacity * 255);
        this.p.text(pressText, startX, this.p.height / 2 + 90);

        // Draw button text with arcade button glow effect
        const buttonX = startX + this.p.textWidth(pressText);

        // Use Arial for Korean button text
        this.p.textFont("Arial");
        this.p.textStyle(this.p.BOLD);

        // Calculate button dimensions
        const buttonPadding = 10;
        const buttonHeight = 30;
        const buttonWidth = this.p.textWidth(buttonText) + buttonPadding * 2;
        const buttonY = this.p.height / 2 + 90 - buttonHeight / 2;

        // Draw button base (shadow)
        this.p.fill(44, 132, 76, this.startTextOpacity * 255);
        this.p.noStroke();
        this.p.rect(buttonX, buttonY + 4, buttonWidth, buttonHeight, 6);

        // Draw button surface
        this.p.fill(74, 222, 128, this.startTextOpacity * 255);
        this.p.rect(buttonX, buttonY, buttonWidth, buttonHeight, 6);

        // Add highlight to button
        const gradientHeight = buttonHeight * 0.4;
        this.p.fill(255, 255, 255, this.startTextOpacity * 40);
        this.p.rect(buttonX, buttonY, buttonWidth, gradientHeight, 6, 6, 0, 0);

        // Outer button glow
        this.p.fill(74, 222, 128, this.startTextOpacity * 80);
        for (let offset = 2; offset >= 1; offset--) {
          this.p.text(
            buttonText,
            buttonX + buttonPadding - offset,
            buttonY + buttonHeight / 2 + 4 - offset
          );
          this.p.text(
            buttonText,
            buttonX + buttonPadding + offset,
            buttonY + buttonHeight / 2 + 4 + offset
          );
        }

        // Inner button text
        this.p.fill(255, 255, 255, this.startTextOpacity * 255);
        this.p.text(
          buttonText,
          buttonX + buttonPadding,
          buttonY + buttonHeight / 2
        );

        // Draw "TO START/RESTART" with normal opacity
        this.p.textFont(this.pixelFont);
        this.p.fill(255, 255, 255, this.startTextOpacity * 255);
        this.p.text(
          toStartText,
          buttonX + buttonWidth + 5,
          this.p.height / 2 + 90
        );

        this.p.pop();
      }

      // Draw last typed character with enhanced arcade effect
      if (this.lastTypedChar && this.isPlaying && !this.isPaused) {
        const timeSinceTyped = this.p.millis() - this.lastTypedCharTime;
        const fadeTime = 1000;
        if (timeSinceTyped < fadeTime) {
          this.p.push();
          const baseSize = 50;
          this.p.textAlign(this.p.CENTER, this.p.CENTER);
          const opacity = this.p.map(timeSinceTyped, 0, fadeTime, 255, 0);

          // Use koreanPixelFont for Korean characters
          if (isHangul(this.lastTypedChar)) {
            this.p.textFont(this.koreanPixelFont);
            this.p.textStyle(this.p.BOLD);
          } else {
            this.p.textFont(this.pixelFont);
          }

          // Draw outer glow
          const glowColor = this.p.color(this.lastTypedCharColor);
          glowColor.setAlpha(opacity * 0.3);
          this.p.fill(glowColor);
          this.p.textSize(baseSize + 6);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          // Draw middle glow
          glowColor.setAlpha(opacity * 0.6);
          this.p.fill(glowColor);
          this.p.textSize(baseSize + 3);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          // Draw main character
          const c = this.p.color(this.lastTypedCharColor);
          c.setAlpha(opacity);
          this.p.fill(c);
          this.p.textSize(baseSize);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          // Draw inner highlight
          const highlightColor = this.p.color("#ffffff");
          highlightColor.setAlpha(opacity * 0.7);
          this.p.fill(highlightColor);
          this.p.textSize(baseSize * 0.9);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          this.p.pop();
        } else {
          this.lastTypedChar = null;
        }
      }
    }

    handleKeyPress(key: string): void {
      if (!this.isPlaying) return;

      const charIndex = this.fallingChars.findIndex(
        (char) =>
          char.char.toLowerCase() === key.toLowerCase() && !char.isBackground
      );

      this.lastTypedChar = key;
      this.lastTypedCharTime = this.p.millis();

      if (charIndex !== -1) {
        // Matched a falling character - use neon colors for success
        this.lastTypedCharColor = "#00ff00";
        this.fallingChars.splice(charIndex, 1);
        this.score += 10;
      } else {
        // No match found - use hot pink for errors
        this.lastTypedCharColor = "#ff0066";
      }
    }
  }

  // Initialize p5.js
  new p5((p: p5) => {
    let game: Game;
    let pixelFont: p5.Font;
    let koreanPixelFont: p5.Font;
    const container = document.getElementById("game-container");
    if (!container) return;

    p.preload = () => {
      pixelFont = p.loadFont("/fonts/PressStart2P-Regular.ttf");
      koreanPixelFont = p.loadFont("/fonts/UnifontExMono.ttf");
    };

    p.setup = () => {
      const canvas = p.createCanvas(
        container.clientWidth,
        container.clientWidth * 0.75
      );
      canvas.parent(container);
      game = new Game(p, pixelFont, koreanPixelFont);
      game.numColumns = Math.floor(p.width / game.columnWidth);
      p.textFont(pixelFont);

      // Setup input handling
      game.setupInput();

      // Setup start button
      const startButton = document.getElementById("start-button");
      if (startButton) {
        startButton.addEventListener("click", () => {
          if (!game.isPlaying) {
            game.start();
          } else {
            game.togglePause();
          }
          // Focus the input after starting
          const input = document.getElementById(
            "korean-input"
          ) as HTMLInputElement;
          if (input && !game.isPaused) {
            input.focus();
          }
        });
      }
    };

    p.draw = () => {
      game.update();
      game.draw();
    };

    p.mousePressed = () => {
      // Remove the click-to-start functionality
      if (
        p.mouseX >= 0 &&
        p.mouseX < p.width &&
        p.mouseY >= 0 &&
        p.mouseY < p.height
      ) {
        game.start();
      }
    };

    // Handle window resize
    p.windowResized = () => {
      p.resizeCanvas(container.clientWidth, container.clientWidth * 0.75);
      game.numColumns = Math.floor(p.width / game.columnWidth);
    };
  });
</script>
