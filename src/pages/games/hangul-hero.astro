---
import Header from "~/components/Header.astro";
import BaseLayout from "../../layouts/base.astro";
---

<BaseLayout title="Hangul Hero - Korean Typing Game">
  <header class="lg-:container mx-auto px-6 py-2 max-w-screen-lg">
    <Header />
  </header>
  <main class="container mx-auto px-4 py-8">
    <div class="max-w-2xl mx-auto">
      <div class="arcade-cabinet">
        <div class="cabinet-top">
          <div class="marquee">
            <div class="marquee-pattern"></div>
            <div class="marquee-decoration left">
              <div class="korean-chars">
                <div class="char-column">
                  <span style="color: #FF6B6B">ㄱ</span>
                  <span style="color: #4ECDC4">ㅏ</span>
                  <span style="color: #45B7D1">ㄴ</span>
                  <span style="color: #96CEB4">ㅗ</span>
                  <span style="color: #FFEEAD">ㄹ</span>
                  <span style="color: #D4A5A5">ㅎ</span>
                </div>
                <div class="char-column">
                  <span style="color: #45B7D1">ㅂ</span>
                  <span style="color: #FF6B6B">ㅓ</span>
                  <span style="color: #FFEEAD">ㅅ</span>
                  <span style="color: #4ECDC4">ㅜ</span>
                  <span style="color: #96CEB4">ㅈ</span>
                  <span style="color: #D4A5A5">ㅣ</span>
                </div>
                <div class="char-column">
                  <span style="color: #FF6B6B">ㅊ</span>
                  <span style="color: #4ECDC4">ㅑ</span>
                  <span style="color: #45B7D1">ㅋ</span>
                  <span style="color: #FFEEAD">ㅠ</span>
                  <span style="color: #96CEB4">ㅌ</span>
                  <span style="color: #D4A5A5">ㅡ</span>
                </div>
              </div>
            </div>
            <div class="marquee-decoration right">
              <div class="korean-chars">
                <div class="char-column">
                  <span style="color: #4ECDC4">ㅍ</span>
                  <span style="color: #FF6B6B">ㅕ</span>
                  <span style="color: #96CEB4">ㄷ</span>
                  <span style="color: #FFEEAD">ㅛ</span>
                  <span style="color: #45B7D1">ㅇ</span>
                  <span style="color: #D4A5A5">ㅐ</span>
                </div>
                <div class="char-column">
                  <span style="color: #FF6B6B">ㅁ</span>
                  <span style="color: #4ECDC4">ㅔ</span>
                  <span style="color: #D4A5A5">ㅃ</span>
                  <span style="color: #96CEB4">ㅒ</span>
                  <span style="color: #FFEEAD">ㄸ</span>
                  <span style="color: #45B7D1">ㅉ</span>
                </div>
                <div class="char-column">
                  <span style="color: #4ECDC4">ㄲ</span>
                  <span style="color: #FF6B6B">ㅖ</span>
                  <span style="color: #96CEB4">ㅆ</span>
                  <span style="color: #FFEEAD">ㅢ</span>
                  <span style="color: #45B7D1">ㅚ</span>
                  <span style="color: #D4A5A5">ㅟ</span>
                </div>
              </div>
            </div>
            <h1
              class="text-8xl font-bold text-center font-bangers tracking-wider marquee-title"
              style="text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;"
            >
              <span style="color: #FF6B6B">한</span><span style="color: #4ECDC4"
                >글</span
              >
              <span style="color: #96CEB4">H</span><span style="color: #FFEEAD"
                >E</span
              ><span style="color: #D4A5A5">R</span><span style="color: #FF6B6B"
                >O</span
              >
            </h1>
          </div>
        </div>
        <div class="screen-bezel">
          <div class="screen-container">
            <div class="screen-overlay"></div>
            <div class="screen-content">
              <div id="game-container" class="game-screen">
                <input
                  type="text"
                  id="korean-input"
                  class="opacity-0 absolute pointer-events-none w-0 h-0 overflow-hidden"
                  autocomplete="off"
                  aria-hidden="true"
                />
              </div>
            </div>
          </div>
        </div>
        <div class="cabinet-bottom">
          <div class="control-panel">
            <div class="speaker-grill">
              <div class="speaker-pattern"></div>
            </div>
            <div class="led-container">
              <div class="led-housing">
                <div class="led-glow"></div>
                <div class="led-core"></div>
                <div class="led-highlight"></div>
              </div>
            </div>
            <div class="button-mount">
              <button id="start-button" class="arcade-start-button off">
                <div class="button-trim">
                  <div class="button-surface">
                    <div class="button-text">시작</div>
                  </div>
                  <div class="button-base"></div>
                </div>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="text-center mt-4 text-sm text-gray-400">
      <a
        href="mailto:hangul-hero@just-be.dev"
        class="bg-gradient-to-r from-[#ff3366] to-[#ff6633] bg-clip-text text-transparent hover:from-[#ff6633] hover:to-[#ff3366] transition-all duration-300 animate-gradient bg-[length:200%_auto]"
        >Email me</a
      > to leave feedback or report bugs
    </div>
  </main>
</BaseLayout>

<style>
  :root {
    --cabinet-color: #c8b2b2;
    --button-color: #4ade80; /* Light green */
    --button-glow: rgba(74, 222, 128, 0.5);
    --button-color-active: #fbbf24; /* Amber/yellow */
    --button-glow-active: rgba(251, 191, 36, 0.5);
    --button-color-off: #ef4444; /* Red */
    --button-glow-off: rgba(239, 68, 68, 0.5);
  }

  .arcade-cabinet {
    background: linear-gradient(
      45deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    padding: 2rem;
    border-radius: 1rem;
    box-shadow:
      0 0 0 4px color-mix(in srgb, var(--cabinet-color) 85%, black),
      0 0 0 8px color-mix(in srgb, var(--cabinet-color) 75%, black),
      0 10px 20px rgba(0, 0, 0, 0.5);
    border: 1px solid color-mix(in srgb, var(--cabinet-color) 65%, black);
  }

  .arcade-cabinet::before {
    display: none;
  }

  .cabinet-top {
    margin: -2rem -2rem 1rem -2rem;
    padding: 1.5rem;
    background: linear-gradient(
      180deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    border-radius: 1rem 1rem 0 0;
    border-bottom: 4px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
    box-shadow:
      inset 0 2px 5px rgba(255, 255, 255, 0.2),
      inset 0 -2px 5px rgba(0, 0, 0, 0.2);
  }

  .cabinet-bottom {
    margin: 1rem -2rem -2rem -2rem;
    padding: 1rem;
    background: linear-gradient(
      0deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    border-radius: 0 0 1rem 1rem;
    border-top: 4px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
  }

  .control-panel {
    background: linear-gradient(
      90deg,
      var(--cabinet-color),
      color-mix(in srgb, var(--cabinet-color) 85%, black),
      var(--cabinet-color)
    );
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow:
      inset 0 2px 8px rgba(255, 255, 255, 0.15),
      inset 0 -2px 8px rgba(0, 0, 0, 0.2),
      0 2px 4px rgba(0, 0, 0, 0.15);
    text-align: center;
    position: relative;
    min-height: 80px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem;
    border: 1px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
  }

  .speaker-grill {
    position: relative;
    width: 140px;
    height: 124px;
    background: linear-gradient(
      135deg,
      color-mix(in srgb, var(--cabinet-color) 95%, black) 0%,
      color-mix(in srgb, var(--cabinet-color) 85%, black) 50%,
      color-mix(in srgb, var(--cabinet-color) 98%, black) 100%
    );
    border-radius: 4px;
    box-shadow:
      inset 0 2px 8px rgba(0, 0, 0, 0.5),
      inset -2px -2px 6px rgba(0, 0, 0, 0.4),
      inset 2px 2px 6px rgba(255, 255, 255, 0.15),
      1px 1px 2px rgba(255, 255, 255, 0.1);
    overflow: hidden;
    margin: -3rem 0rem -3rem -1.5rem;
    border-radius: 0.5rem 50% 50% 0.5rem;
    border: 1px solid color-mix(in srgb, var(--cabinet-color) 65%, black);
  }

  .speaker-pattern {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: radial-gradient(
        circle at center,
        rgba(0, 0, 0, 0.7) 0,
        rgba(0, 0, 0, 0.7) 1.5px,
        transparent 1.5px
      ),
      linear-gradient(
        135deg,
        transparent 0%,
        rgba(0, 0, 0, 0.15) 50%,
        transparent 100%
      );
    background-size:
      6px 6px,
      100% 100%;
    background-position:
      2px 2px,
      0 0;
    opacity: 0.85;
  }

  .speaker-inner {
    display: none;
  }

  .button-mount {
    position: relative;
    width: 92px;
    height: 92px;
    background: linear-gradient(
      45deg,
      color-mix(in srgb, var(--cabinet-color) 85%, white),
      var(--cabinet-color)
    );
    border-radius: 14px;
    padding: 4px 6px 4px 4px;
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.8),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    border: 2px solid color-mix(in srgb, var(--cabinet-color) 75%, black);
    transform: translateZ(5px);
    transition: box-shadow 0.1s;
  }

  .button-mount::before {
    content: "";
    position: absolute;
    top: 2px;
    left: 2px;
    right: 2px;
    bottom: 2px;
    border-radius: 10px;
    background: linear-gradient(
      45deg,
      color-mix(in srgb, var(--cabinet-color) 90%, white),
      color-mix(in srgb, var(--cabinet-color) 85%, white)
    );
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.8),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    z-index: 0;
  }

  .button-mount::after {
    content: "";
    position: absolute;
    top: 4px;
    left: 4px;
    right: 4px;
    bottom: 4px;
    border-radius: 8px;
    background: linear-gradient(45deg, #2a2a2a, #1a1a1a);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 0;
  }

  .arcade-start-button:active + .button-mount {
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.8),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
  }

  .arcade-start-button.active + .button-mount {
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.8),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
  }

  .arcade-start-button.active:active + .button-mount {
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.8),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
  }

  .button-trim {
    position: relative;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, #2a2a2a, #1a1a1a);
    border-radius: 10px;
    padding: 2px;
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.5),
      0 4px 8px rgba(0, 0, 0, 0.4),
      0 8px 16px rgba(0, 0, 0, 0.3);
    transform: translateZ(10px);
  }

  .arcade-start-button {
    position: relative;
    width: 80px;
    height: 80px;
    border: none;
    background: none;
    cursor: pointer;
    outline: none;
    padding: 0;
    transform-style: preserve-3d;
    transform: translateZ(15px);
    z-index: 1;
  }

  .arcade-start-button:active .button-surface {
    transform: translateY(0);
    box-shadow:
      0 0 15px var(--button-glow),
      0 0 30px var(--button-glow),
      0 0 45px var(--button-glow),
      inset 0 0 8px rgba(255, 255, 255, 0.5);
  }

  .arcade-start-button .button-surface {
    position: absolute;
    top: 1px;
    left: 2px;
    width: calc(100% - 4px);
    height: calc(100% - 4px);
    background: radial-gradient(
      circle at 30% 30%,
      color-mix(in srgb, var(--button-color) 85%, white),
      var(--button-color) 60%,
      color-mix(in srgb, var(--button-color) 85%, black)
    );
    border-radius: 8px;
    transform: translateY(-4px) translateZ(20px);
    transition:
      transform 0.1s,
      box-shadow 0.1s,
      background 0.3s;
    box-shadow:
      0 0 30px var(--button-glow),
      0 0 60px var(--button-glow),
      0 0 90px var(--button-glow),
      inset 0 0 15px rgba(255, 255, 255, 0.8),
      inset 2px 2px 2px rgba(255, 255, 255, 0.5),
      inset -2px -2px 2px rgba(0, 0, 0, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.4),
      0 8px 16px rgba(0, 0, 0, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
  }

  .button-base {
    position: absolute;
    top: 2px;
    left: 2px;
    width: calc(100% - 4px);
    height: calc(100% - 4px);
    background: color-mix(in srgb, var(--button-color) 85%, black);
    border-radius: 8px;
    z-index: 1;
    box-shadow:
      inset 0 0 2px rgba(0, 0, 0, 0.5),
      0 4px 8px rgba(0, 0, 0, 0.4),
      0 8px 16px rgba(0, 0, 0, 0.3);
    transition: background 0.3s;
  }

  .button-text {
    color: white;
    font-family: Arial, sans-serif;
    font-size: 32px;
    font-weight: 800;
    text-shadow:
      0 0 5px rgba(255, 255, 255, 0.8),
      0 0 10px rgba(255, 255, 255, 0.5);
    transform: translateY(-1px);
  }

  .marquee {
    position: relative;
    background: linear-gradient(90deg, #ff3366, #ff6633);
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow:
      inset 0 0 20px rgba(255, 255, 255, 0.5),
      inset 0 0 40px rgba(255, 255, 255, 0.2),
      0 2px 4px rgba(0, 0, 0, 0.3);
    text-align: center;
    overflow: hidden;
    border: 2px solid #333;
  }

  .marquee::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: radial-gradient(
        circle at 50% 50%,
        rgba(255, 255, 255, 0.2) 0%,
        transparent 60%
      ),
      linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.1) 0%,
        rgba(255, 255, 255, 0.2) 25%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0.2) 75%,
        rgba(255, 255, 255, 0.1) 100%
      );
    animation: shine 3s linear infinite;
  }

  .marquee-decoration {
    position: absolute;
    top: 50%;
    width: 160px;
    transform: translateY(-50%);
  }

  .marquee-decoration.left {
    left: 0;
  }

  .marquee-decoration.right {
    right: 0;
  }

  .korean-chars {
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  .char-column {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }

  .korean-chars span {
    font-size: 20px;
    font-weight: bold;
    text-shadow:
      0 0 5px currentColor,
      0 0 10px currentColor,
      0 0 15px currentColor;
  }

  .marquee-pattern {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 25% 50%, #fff 1px, transparent 1px),
      radial-gradient(circle at 75% 50%, #fff 1px, transparent 1px);
    background-size: 40px 40px;
    opacity: 0.1;
    animation: twinkle 2s ease-in-out infinite alternate;
  }

  @keyframes shine {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }

  @keyframes twinkle {
    from {
      opacity: 0.05;
    }
    to {
      opacity: 0.15;
    }
  }

  .marquee-title {
    position: relative;
    z-index: 1;
    margin: 0;
    padding: 0.5rem;
    background: linear-gradient(
      90deg,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0.1) 20%,
      rgba(255, 255, 255, 0.1) 80%,
      rgba(255, 255, 255, 0) 100%
    );
    animation: title-shine 3s ease-in-out infinite;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
  }

  @keyframes title-shine {
    0%,
    100% {
      background-position: -200% center;
    }
    50% {
      background-position: 200% center;
    }
  }

  .screen-bezel {
    background: linear-gradient(45deg, #111, #333);
    padding: 1rem;
    border-radius: 1rem;
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.3);
    border: 2px solid #444;
  }

  .screen-container {
    position: relative;
    background: #000;
    border-radius: 0.5rem;
    overflow: hidden;
    border: 2px solid #1a1a1a;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
  }

  .screen-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        rgba(18, 16, 16, 0) 50%,
        rgba(0, 0, 0, 0.25) 50%
      ),
      linear-gradient(
        90deg,
        rgba(255, 0, 0, 0.06),
        rgba(0, 255, 0, 0.02),
        rgba(0, 0, 255, 0.06)
      );
    background-size:
      100% 2px,
      3px 100%;
    pointer-events: none;
    z-index: 10;
    border-radius: 0.5rem;
  }

  .screen-content {
    position: relative;
    z-index: 1;
    background: #000;
    animation: flicker 0.15s infinite;
  }

  .game-screen {
    background: #000;
    position: relative;
    overflow: hidden;
    min-height: 400px;
  }

  #game-container canvas {
    border-radius: 0;
    display: block;
  }

  @keyframes flicker {
    0% {
      opacity: 0.97;
    }
    5% {
      opacity: 0.95;
    }
    10% {
      opacity: 0.9;
    }
    15% {
      opacity: 0.95;
    }
    20% {
      opacity: 0.98;
    }
    25% {
      opacity: 0.95;
    }
    30% {
      opacity: 0.9;
    }
    35% {
      opacity: 0.95;
    }
    40% {
      opacity: 0.98;
    }
    45% {
      opacity: 0.95;
    }
    50% {
      opacity: 0.9;
    }
    55% {
      opacity: 0.95;
    }
    60% {
      opacity: 0.98;
    }
    65% {
      opacity: 0.95;
    }
    70% {
      opacity: 0.9;
    }
    75% {
      opacity: 0.95;
    }
    80% {
      opacity: 0.98;
    }
    85% {
      opacity: 0.95;
    }
    90% {
      opacity: 0.9;
    }
    95% {
      opacity: 0.95;
    }
    100% {
      opacity: 0.98;
    }
  }

  .arcade-start-button.active .button-surface {
    background: radial-gradient(
      circle at 30% 30%,
      color-mix(in srgb, var(--button-color-active) 85%, white),
      var(--button-color-active) 60%,
      color-mix(in srgb, var(--button-color-active) 85%, black)
    );
    box-shadow:
      0 0 30px var(--button-glow-active),
      0 0 60px var(--button-glow-active),
      0 0 90px var(--button-glow-active),
      inset 0 0 15px rgba(255, 255, 255, 0.8),
      inset 2px 2px 2px rgba(255, 255, 255, 0.5),
      inset -2px -2px 2px rgba(0, 0, 0, 0.3);
  }

  .arcade-start-button.active:active .button-surface {
    box-shadow:
      0 0 15px var(--button-glow-active),
      0 0 30px var(--button-glow-active),
      0 0 45px var(--button-glow-active),
      inset 0 0 8px rgba(255, 255, 255, 0.5);
  }

  .arcade-start-button.active .button-base {
    background: color-mix(in srgb, var(--button-color-active) 85%, black);
  }

  .arcade-start-button:active .button-trim {
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.5),
      0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .arcade-start-button.active:active .button-trim {
    box-shadow:
      inset 0 0 10px rgba(0, 0, 0, 0.5),
      0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .led-container {
    position: relative;
    width: 24px;
    height: 24px;
    margin-right: 20px;
    z-index: 10;
  }

  .led-housing {
    position: relative;
    width: 100%;
    height: 100%;
    z-index: 11;
    border-radius: 50%;
    overflow: hidden;
    transition: box-shadow 0.5s ease;
  }

  .led-housing::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
    border-radius: 50%;
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.1),
      inset 0 -2px 4px rgba(0, 0, 0, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.2);
    z-index: 12;
    transition: box-shadow 0.5s ease;
  }

  .led-housing::after {
    content: "";
    position: absolute;
    top: 2px;
    left: 2px;
    right: 2px;
    bottom: 2px;
    background: linear-gradient(135deg, #333333, #2a2a2a);
    border-radius: 50%;
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.15),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    z-index: 13;
    transition: box-shadow 0.5s ease;
  }

  .led-glow {
    position: absolute;
    top: 4px;
    left: 4px;
    right: 4px;
    bottom: 4px;
    background: radial-gradient(
      circle at 30% 30%,
      rgba(255, 0, 0, 0.8) 0%,
      rgba(255, 0, 0, 0.4) 50%,
      rgba(255, 0, 0, 0) 100%
    );
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.5s ease;
    filter: blur(1px);
    z-index: 14;
  }

  .led-core {
    position: absolute;
    top: 6px;
    left: 6px;
    right: 6px;
    bottom: 6px;
    background: radial-gradient(
      circle at 30% 30%,
      #ff0000 0%,
      #cc0000 50%,
      #990000 100%
    );
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.5s ease;
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.3),
      inset 0 -2px 4px rgba(0, 0, 0, 0.5);
    z-index: 15;
  }

  .led-highlight {
    position: absolute;
    top: 7px;
    left: 7px;
    width: 6px;
    height: 6px;
    background: radial-gradient(
      circle at center,
      rgba(255, 255, 255, 0.9) 0%,
      rgba(255, 255, 255, 0.4) 50%,
      rgba(255, 255, 255, 0) 100%
    );
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.5s ease;
    filter: blur(0.5px);
    z-index: 16;
  }

  .led-housing.powered {
    box-shadow:
      0 0 10px rgba(255, 0, 0, 0.3),
      0 0 20px rgba(255, 0, 0, 0.2),
      0 0 30px rgba(255, 0, 0, 0.1);
  }

  .led-housing.powered::before {
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.1),
      inset 0 -2px 4px rgba(0, 0, 0, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.2),
      0 0 5px rgba(255, 0, 0, 0.2);
  }

  .led-housing.powered::after {
    box-shadow:
      inset 0 2px 4px rgba(255, 255, 255, 0.15),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2),
      0 0 3px rgba(255, 0, 0, 0.3);
  }

  .led-housing.powered .led-glow,
  .led-housing.powered .led-core,
  .led-housing.powered .led-highlight {
    opacity: 1;
  }

  @keyframes ledPulse {
    0%,
    100% {
      opacity: 0.3;
    }
    50% {
      opacity: 1;
    }
  }

  .arcade-start-button.off .button-surface {
    background: radial-gradient(
      circle at 30% 30%,
      color-mix(in srgb, var(--button-color-off) 85%, white),
      var(--button-color-off) 60%,
      color-mix(in srgb, var(--button-color-off) 85%, black)
    );
    box-shadow:
      0 0 30px var(--button-glow-off),
      0 0 60px var(--button-glow-off),
      0 0 90px var(--button-glow-off),
      inset 0 0 15px rgba(255, 255, 255, 0.8),
      inset 2px 2px 2px rgba(255, 255, 255, 0.5),
      inset -2px -2px 2px rgba(0, 0, 0, 0.3);
  }

  .arcade-start-button.off:active .button-surface {
    box-shadow:
      0 0 15px var(--button-glow-off),
      0 0 30px var(--button-glow-off),
      0 0 45px var(--button-glow-off),
      inset 0 0 8px rgba(255, 255, 255, 0.5);
  }

  .arcade-start-button.off .button-base {
    background: color-mix(in srgb, var(--button-color-off) 85%, black);
  }

  @keyframes ledPulse {
    0%,
    100% {
      opacity: 0.3;
    }
    50% {
      opacity: 1;
    }
  }

  .arcade-start-button.off .button-surface {
    background: radial-gradient(
      circle at 30% 30%,
      color-mix(in srgb, var(--button-color-off) 85%, white),
      var(--button-color-off) 60%,
      color-mix(in srgb, var(--button-color-off) 85%, black)
    );
    box-shadow:
      0 0 30px var(--button-glow-off),
      0 0 60px var(--button-glow-off),
      0 0 90px var(--button-glow-off),
      inset 0 0 15px rgba(255, 255, 255, 0.8),
      inset 2px 2px 2px rgba(255, 255, 255, 0.5),
      inset -2px -2px 2px rgba(0, 0, 0, 0.3);
  }

  .arcade-start-button.off:active .button-surface {
    box-shadow:
      0 0 15px var(--button-glow-off),
      0 0 30px var(--button-glow-off),
      0 0 45px var(--button-glow-off),
      inset 0 0 8px rgba(255, 255, 255, 0.5);
  }

  .arcade-start-button.off .button-base {
    background: color-mix(in srgb, var(--button-color-off) 85%, black);
  }

  @keyframes gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }

  .animate-gradient {
    animation: gradient 3s ease infinite;
  }
</style>

<script>
  import p5 from "p5";
  import "p5/lib/addons/p5.sound";

  // Basic Hangul characters (consonants and vowels)
  const HANGUL_CHARS = [
    "ㄱ",
    "ㄴ",
    "ㄷ",
    "ㄹ",
    "ㅁ",
    "ㅂ",
    "ㅅ",
    "ㅇ",
    "ㅈ",
    "ㅊ",
    "ㅋ",
    "ㅌ",
    "ㅍ",
    "ㅎ",
    "ㅏ",
    "ㅑ",
    "ㅓ",
    "ㅕ",
    "ㅗ",
    "ㅛ",
    "ㅜ",
    "ㅠ",
    "ㅡ",
    "ㅣ",
  ];

  // Helper function to check if a character is Hangul
  function isHangul(char: string): boolean {
    return /[\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3]/.test(char);
  }

  class FallingChar {
    x: number;
    y: number;
    char: string;
    speed: number;
    isBackground: boolean;
    color: string;
    size: number;
    opacity: number;
    toDelete: boolean;
    koreanPixelFont: p5.Font;
    isGrowing: boolean;
    growthStartTime: number;
    growthDuration: number;
    wasSuccessfullyHit: boolean; // Add this new property
    private p: p5;

    constructor(
      x: number,
      char: string,
      speed: number,
      koreanPixelFont: p5.Font,
      p: p5,
      isBackground = false
    ) {
      this.x = x;
      this.y = -30;
      this.char = char;
      this.speed = speed;
      this.isBackground = isBackground;
      this.color = isBackground ? this.getRandomColor() : "#FFFFFF";
      this.size = isBackground ? 24 : 32;
      this.opacity = isBackground ? 0.3 : 1;
      this.toDelete = false;
      this.koreanPixelFont = koreanPixelFont;
      this.isGrowing = false;
      this.growthStartTime = 0;
      this.growthDuration = 200; // Duration of growth animation in ms
      this.wasSuccessfullyHit = false; // Initialize the new property
      this.p = p;
    }

    getRandomColor(): string {
      const colors = [
        "#00ff00", // Neon green
        "#ff0066", // Hot pink
        "#00ffff", // Cyan
        "#ffff00", // Yellow
        "#ff3399", // Pink
        "#33ccff", // Light blue
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    update(): void {
      this.y += this.speed;

      if (this.isGrowing) {
        const currentTime = performance.now();
        const elapsed = currentTime - this.growthStartTime;
        const progress = Math.min(elapsed / this.growthDuration, 1);

        // Ease out cubic function for smooth growth
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        this.size = 32 + easedProgress * 48; // Grow from 32 to 80

        // Interpolate color to green
        const startColor = this.p.color(this.color);
        const endColor = this.p.color("#00ff00");
        this.color = this.p
          .lerpColor(startColor, endColor, easedProgress)
          .toString();

        if (progress >= 1) {
          this.toDelete = true;
        }
      }
    }

    startGrowth(): void {
      this.isGrowing = true;
      this.growthStartTime = performance.now();
    }

    draw(p: p5): void {
      p.push();
      p.textSize(this.size);
      p.textAlign(p.CENTER, p.CENTER);
      p.textStyle(p.BOLD);
      p.textFont(this.koreanPixelFont);

      // Draw outer glow
      if (!this.isBackground) {
        const glowColor = p.color(this.color);
        glowColor.setAlpha(this.opacity * 80);
        p.fill(glowColor);
        p.textSize(this.size + 4);
        p.text(this.char, this.x, this.y);

        // Draw middle glow
        glowColor.setAlpha(this.opacity * 120);
        p.fill(glowColor);
        p.textSize(this.size + 2);
        p.text(this.char, this.x, this.y);
      }

      // Draw main character
      const c = p.color(this.color);
      c.setAlpha(this.opacity * 255);
      p.fill(c);
      p.textSize(this.size);
      p.noStroke();
      p.text(this.char, this.x, this.y);

      // Draw inner highlight
      if (!this.isBackground) {
        const highlightColor = p.color("#ffffff");
        highlightColor.setAlpha(this.opacity * 180);
        p.fill(highlightColor);
        p.textSize(this.size * 0.9);
        p.text(this.char, this.x, this.y);
      }
      p.pop();
    }
  }

  class ScoreAnimation {
    x: number;
    y: number;
    opacity: number;
    startTime: number;
    duration: number;
    text: string;

    constructor(x: number, y: number, text: string) {
      this.x = x + 54;
      this.y = y;
      this.opacity = 1;
      this.startTime = performance.now();
      this.duration = 1000; // Animation duration in milliseconds
      this.text = text;
    }

    update(): boolean {
      const elapsed = performance.now() - this.startTime;
      const progress = elapsed / this.duration;

      if (progress >= 1) {
        return false; // Animation is complete
      }

      this.opacity = 1 - progress;
      this.y -= 1; // Move upward
      return true;
    }

    draw(p: p5, font: p5.Font): void {
      p.push();
      p.textFont(font);
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(16);
      p.fill(255, 0, 0, this.opacity * 255);
      p.text(this.text, this.x, this.y);
      p.pop();
    }
  }

  class Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    alpha: number;
    size: number;
    color: string;
    koreanPixelFont: p5.Font;

    constructor(
      x: number,
      y: number,
      char: string,
      koreanPixelFont: p5.Font,
      isSuccess: boolean = false
    ) {
      this.x = x;
      this.y = y;
      // Increase velocity range for more explosive effect
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 8 + 4; // Random speed between 4 and 12
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed - 2; // Initial upward boost
      this.alpha = 1;
      // Fixed pixel sizes for sharper look
      this.size = Math.floor(Math.random() * 3) * 2 + 2; // 2, 4, or 6 pixels
      // Get a random neon color based on success/failure
      this.color = this.getRandomColor(isSuccess);
      this.koreanPixelFont = koreanPixelFont;
    }

    getRandomColor(isSuccess: boolean): string {
      if (isSuccess) {
        // Success colors - bright, positive colors
        const successColors = [
          "#00ff00", // Neon green
          "#00ffff", // Cyan
          "#ffff00", // Yellow
          "#33ccff", // Light blue
          "#4ECDC4", // Teal
        ];
        return successColors[Math.floor(Math.random() * successColors.length)];
      } else {
        // Failure colors - reds and pinks
        const failureColors = [
          "#ff0066", // Hot pink
          "#ff3399", // Pink
          "#FF6B6B", // Pink/Red
          "#ff0000", // Pure red
          "#ff3366", // Bright pink
        ];
        return failureColors[Math.floor(Math.random() * failureColors.length)];
      }
    }

    update(): boolean {
      // Apply gravity
      this.vy += 0.3;

      // Add some horizontal drift
      this.vx *= 0.99;

      // Update position
      this.x += this.vx;
      this.y += this.vy;

      // Fade out faster for sharper disappearance
      this.alpha -= 0.03;

      // Keep size constant for pixel-perfect look
      // this.size *= 0.99; // Removed size reduction

      // Return true if particle is still alive
      return this.alpha > 0;
    }

    draw(p: p5): void {
      p.push();
      p.noStroke();

      // Calculate pixel-perfect position
      const pixelX = Math.round(this.x);
      const pixelY = Math.round(this.y);

      // Draw main pixel
      const mainColor = p.color(this.color);
      mainColor.setAlpha(this.alpha * 255);
      p.fill(mainColor);
      p.rect(
        pixelX - this.size / 2,
        pixelY - this.size / 2,
        this.size,
        this.size
      );

      // Draw white highlight pixel in corner (1px)
      const highlightColor = p.color("#ffffff");
      highlightColor.setAlpha(this.alpha * 255);
      p.fill(highlightColor);
      p.rect(pixelX - this.size / 2, pixelY - this.size / 2, 1, 1);

      // Draw dark edge on bottom-right (1px)
      const shadowColor = p.color(0, 0, 0);
      shadowColor.setAlpha(this.alpha * 255);
      p.fill(shadowColor);
      p.rect(pixelX + this.size / 2 - 1, pixelY + this.size / 2 - 1, 1, 1);

      p.pop();
    }
  }

  class LifeCharacter {
    x: number;
    y: number;
    baseY: number;
    char: string;
    color: string;
    isLost: boolean;
    bobOffset: number;
    private font: p5.Font;

    // Predefined distinct colors for life indicators
    static readonly LIFE_COLORS = [
      "#FF6B6B", // Pink/Red
      "#4ECDC4", // Teal
      "#45B7D1", // Light Blue
      "#96CEB4", // Sage
      "#FFEEAD", // Light Yellow
      "#D4A5A5", // Light Pink
      "#ff0066", // Hot pink
      "#00ff00", // Neon green
      "#00ffff", // Cyan
      "#ffff00", // Yellow
      "#ff3399", // Pink
      "#33ccff", // Light blue
    ];

    constructor(
      x: number,
      y: number,
      font: p5.Font,
      availableColors: string[]
    ) {
      this.x = x;
      this.y = y;
      this.baseY = y;
      this.char = "●";
      this.isLost = false;
      this.bobOffset = Math.random() * Math.PI * 2; // Random starting phase
      // Randomly select a color from the available colors
      const randomIndex = Math.floor(Math.random() * availableColors.length);
      this.color = availableColors[randomIndex];
      this.font = font;
    }

    update(p: p5, currentTime: number): void {
      if (!this.isLost) {
        // Bob up and down
        this.y = this.baseY + Math.sin(currentTime / 400 + this.bobOffset) * 3;
      }
    }

    draw(p: p5): void {
      p.push();
      p.textAlign(p.CENTER, p.CENTER);
      p.textFont(this.font);
      p.textSize(32);

      const displayColor = this.isLost ? "#FF0000" : this.color;

      if (this.isLost) {
        // Draw the lost character (Korean character that hit bottom)
        // Simple shadow for depth without blur
        p.fill(0, 0, 0, 100);
        p.text(this.char, this.x + 2, this.y + 2);

        // Main character with solid red color
        p.fill(displayColor);
        p.text(this.char, this.x, this.y);
      } else {
        // Draw animated dot
        // Simple shadow for depth
        p.fill(0, 0, 0, 100);
        p.text("●", this.x + 2, this.y + 2);

        // Main dot with fixed color
        p.fill(displayColor);
        p.text("●", this.x, this.y);
      }

      p.pop();
    }

    setLostChar(char: string): void {
      this.char = char;
      this.isLost = true;
    }
  }

  class WarningMessage {
    x: number;
    y: number;
    opacity: number;
    startTime: number;
    duration: number;
    text: string;
    private p: p5;
    private flashCount: number;
    private flashDuration: number;
    private lines: string[];
    private lineHeight: number;

    constructor(p: p5, text: string) {
      this.p = p;
      this.x = p.width / 2;
      this.y = 100; // Position near the top of the screen
      this.opacity = 1;
      this.startTime = performance.now();
      this.duration = 2000; // Animation duration in milliseconds
      this.text = text;
      this.flashCount = 3; // Number of flashes
      this.flashDuration = this.duration / (this.flashCount * 2); // Duration of each flash phase (on/off)
      this.lineHeight = 25; // Space between lines
      this.lines = []; // Will be populated in wrapText()
    }

    private wrapText(p: p5, text: string, maxWidth: number): string[] {
      const words = text.split(" ");
      const lines: string[] = [];
      let currentLine = words[0];

      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const width = p.textWidth(currentLine + " " + word);
        if (width < maxWidth) {
          currentLine += " " + word;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      lines.push(currentLine);
      return lines;
    }

    update(): boolean {
      const elapsed = performance.now() - this.startTime;
      const progress = elapsed / this.duration;

      if (progress >= 1) {
        return false; // Animation is complete
      }

      // Calculate flash effect
      if (progress > 0.6) {
        // Start flashing at 60% of duration
        const flashProgress =
          (elapsed - this.duration * 0.6) / (this.duration * 0.4);
        const flashPhase = (flashProgress * this.flashCount) % 1;
        this.opacity = flashPhase > 0.5 ? 1 : 0.2; // Flash between full and 20% opacity
      } else if (progress < 0.1) {
        this.opacity = progress * 10; // Quick fade in
      } else {
        this.opacity = 1; // Stay fully visible
      }

      return true;
    }

    draw(p: p5, font: p5.Font): void {
      p.push();
      p.textFont(font);
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(16); // Further reduced from 20 to 16

      // Calculate text wrapping if not already done
      if (this.lines.length === 0) {
        this.lines = this.wrapText(p, this.text, p.width * 0.8); // Use 80% of screen width
      }

      // Calculate total height of all lines
      const totalHeight = this.lines.length * this.lineHeight;
      const startY = this.y - totalHeight / 2 + this.lineHeight / 2;

      // Draw each line
      this.lines.forEach((line, i) => {
        const lineY = startY + i * this.lineHeight;

        // Draw text shadow
        p.fill(0, 0, 0, this.opacity * 255);
        p.text(line, this.x + 2, lineY + 2);

        // Draw glowing effect
        const glowColor = p.color(255, 238, 173); // Light yellow RGB values
        for (let j = 4; j >= 1; j--) {
          glowColor.setAlpha(this.opacity * 64);
          p.fill(glowColor);
          p.text(line, this.x, lineY);
        }

        // Draw main text
        p.fill(255, 238, 173, this.opacity * 255); // Light yellow RGB values
        p.text(line, this.x, lineY);
      });

      p.pop();
    }
  }

  class Game {
    private static readonly MAX_LIVES = 3;
    private p: p5;
    public isPlaying: boolean;
    public isPaused: boolean;
    private score: number;
    private lives: number;
    private fallingChars: FallingChar[];
    private backgroundChars: FallingChar[];
    private speed: number;
    private lastTypedChar: string | null;
    private lastTypedCharColor: string;
    private lastTypedCharTime: number;
    private startTextOpacity: number;
    private startTextFading: number;
    public columnWidth: number;
    public numColumns: number;
    private minBackgroundSpacing: number;
    private columnLastY: number[];
    private gameStartTime: number;
    private lastSpawnTime: number;
    private initialSpawnInterval: number;
    private minSpawnInterval: number;
    private maxActiveChars: number;
    private initialSpeed: number;
    private maxSpeed: number;
    private pauseTextOpacity: number;
    private pauseTextFading: number;
    private pixelFont: p5.Font;
    private koreanPixelFont: p5.Font;
    private scoreAnimations: ScoreAnimation[];
    private scoreColor: p5.Color;
    private scoreColorTransitionStart: number;
    private scoreColorTransitionDuration: number;
    private particles: Particle[];
    private flashStartTime: number;
    private isFlashing: boolean;
    private flashDuration: number;
    private flashCount: number;
    private maxFlashCount: number;
    private lifeCharacters: LifeCharacter[];
    private wasScoreZero: boolean;
    public sounds: {
      explosions: p5.SoundFile[];
      buttonPressed: p5.SoundFile;
      buttonReleased: p5.SoundFile;
      gameOver: p5.SoundFile;
      intro: p5.SoundFile;
      success: p5.SoundFile[];
      gameMusic: p5.SoundFile[]; // Changed to array
      gameOverSong: p5.SoundFile;
    };
    private audioContextInitialized: boolean;
    // Add new power state properties
    public isPowered: boolean;
    private screenPowerTransitionStart: number;
    private screenPowerTransitionDuration: number;
    public buttonPressStartTime: number;
    public longPressThreshold: number;
    public isLongPress: boolean;
    private currentGameMusicIndex: number = 0; // Add index tracking
    private warningMessages: WarningMessage[] = [];

    constructor(
      p: p5,
      pixelFont: p5.Font,
      koreanPixelFont: p5.Font,
      sounds: {
        explosions: p5.SoundFile[];
        buttonPressed: p5.SoundFile;
        buttonReleased: p5.SoundFile;
        gameOver: p5.SoundFile;
        intro: p5.SoundFile;
        success: p5.SoundFile[];
        gameMusic: p5.SoundFile[]; // Changed to array
        gameOverSong: p5.SoundFile;
      }
    ) {
      this.p = p;
      this.pixelFont = pixelFont;
      this.koreanPixelFont = koreanPixelFont;
      this.sounds = sounds;
      this.isPlaying = false;
      this.isPaused = false;
      this.score = 0;
      this.lives = Game.MAX_LIVES;
      this.fallingChars = [];
      this.backgroundChars = [];
      this.speed = 1;
      this.lastTypedChar = null;
      this.lastTypedCharColor = "#FFFFFF";
      this.lastTypedCharTime = 0;
      this.columnWidth = 40;
      this.numColumns = 0;
      this.startTextOpacity = 0;
      this.startTextFading = 1;
      this.minBackgroundSpacing = 60;
      this.columnLastY = [];
      this.gameStartTime = 0;
      this.lastSpawnTime = 0;
      this.initialSpawnInterval = 3000;
      this.minSpawnInterval = 500;
      this.maxActiveChars = 1;
      this.initialSpeed = 1;
      this.maxSpeed = 4;
      this.pauseTextOpacity = 0.3;
      this.pauseTextFading = 1;
      this.scoreAnimations = [];
      this.scoreColor = p.color("#00ff00");
      this.scoreColorTransitionStart = 0;
      this.scoreColorTransitionDuration = 500;
      this.particles = [];
      this.flashStartTime = 0;
      this.isFlashing = false;
      this.flashDuration = 1200;
      this.flashCount = 0;
      this.maxFlashCount = 1;
      this.lifeCharacters = [];
      this.wasScoreZero = false;
      this.audioContextInitialized = false;
      // Initialize power state properties
      this.isPowered = false;
      this.screenPowerTransitionStart = 0;
      this.screenPowerTransitionDuration = 1000;
      this.buttonPressStartTime = 0;
      this.longPressThreshold = 5000; // 5 seconds
      this.isLongPress = false;
      this.warningMessages = [];
    }

    private async initializeAudioContext(): Promise<void> {
      if (this.audioContextInitialized) return;

      try {
        await this.p.userStartAudio();
        this.audioContextInitialized = true;
      } catch (error) {
        console.warn("Audio context initialization failed:", error);
      }
    }

    public async playSound(
      sound: p5.SoundFile,
      options: {
        rate?: number;
        volume?: number;
        loop?: boolean;
        /** Delay in seconds */
        delay?: number;
      } = {}
    ): Promise<void> {
      if (!this.audioContextInitialized) {
        await this.initializeAudioContext();
      }
      const startTime = options.delay ?? 0;

      if (sound && this.audioContextInitialized) {
        try {
          if (options.rate) {
            sound.rate(options.rate);
          }
          if (options.volume) {
            sound.setVolume(options.volume);
          }

          if (options.loop) {
            sound.loop(startTime);
          } else {
            sound.play(startTime);
          }
        } catch (error) {
          console.warn("Failed to play sound:", error);
        }
      } else {
        console.warn("Sound not found or audio context not initialized");
      }
    }

    setupInput(): void {
      const input = document.getElementById("korean-input") as HTMLInputElement;
      if (!input) return;

      // Add space bar handler for pause
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && this.isPlaying) {
          e.preventDefault(); // Prevent space from triggering input
          this.togglePause();
        }
      });

      // Focus input when game container is clicked
      const container = document.getElementById("game-container");
      if (container) {
        container.addEventListener("click", () => {
          input.focus({ preventScroll: true });
        });
      }

      // Handle input events
      input.addEventListener("input", (e) => {
        if (!this.isPlaying || this.isPaused || !this.isPowered) return; // Don't process input when powered off or paused

        const char = (e.target as HTMLInputElement).value;
        if (char) {
          this.handleKeyPress(char);
          // Clear the input for the next character
          (e.target as HTMLInputElement).value = "";
        }
      });

      // Keep input focused when typing
      input.addEventListener("blur", () => {
        if (this.isPlaying && !this.isPaused && this.isPowered) {
          input.focus({ preventScroll: true });
        }
      });
    }

    togglePause(): void {
      this.isPaused = !this.isPaused;
      const input = document.getElementById("korean-input") as HTMLInputElement;
      const startButton = document.getElementById("start-button");
      if (this.isPaused) {
        input?.blur(); // Remove focus from input when paused
        startButton?.classList.remove("active");
        // Pause current game music track
        if (
          this.sounds.gameMusic &&
          this.sounds.gameMusic[this.currentGameMusicIndex]
        ) {
          this.sounds.gameMusic[this.currentGameMusicIndex].pause();
        }
      } else {
        input?.focus({ preventScroll: true }); // Restore focus when unpaused
        startButton?.classList.add("active");
        // Resume current game music track
        if (
          this.sounds.gameMusic &&
          this.sounds.gameMusic[this.currentGameMusicIndex]
        ) {
          this.sounds.gameMusic[this.currentGameMusicIndex].play();
        }
      }
    }

    start(): void {
      if (this.isPlaying) return;

      // Stop intro music when game starts
      if (this.sounds.intro) {
        this.sounds.intro.stop();
      }

      // Stop game over song if it's playing
      if (this.sounds.gameOverSong) {
        this.sounds.gameOverSong.stop();
      }

      // Reset music index and start first track
      this.currentGameMusicIndex = 0;
      if (this.sounds.gameMusic && this.sounds.gameMusic.length > 0) {
        this.playNextGameMusicTrack();
      }

      this.isPlaying = true;
      this.isPaused = false;
      this.score = 0;
      this.lives = Game.MAX_LIVES;
      this.fallingChars = [];
      this.speed = this.initialSpeed;
      this.columnLastY = new Array(this.numColumns).fill(
        -this.minBackgroundSpacing
      );
      this.gameStartTime = this.p.millis();
      this.lastSpawnTime = this.gameStartTime;
      this.scoreColor = this.p.color("#00ff00"); // Reset to green when starting
      this.wasScoreZero = false; // Reset the flag when starting

      // Initialize life characters with random non-repeating colors
      this.lifeCharacters = [];
      const startX = this.p.width - 20 - 35 * 2;
      const startY = this.p.height - 30;

      // Create a copy of available colors and shuffle them
      const availableColors = [...LifeCharacter.LIFE_COLORS];
      for (let i = 0; i < Game.MAX_LIVES; i++) {
        this.lifeCharacters.push(
          new LifeCharacter(
            startX + i * 35,
            startY,
            this.koreanPixelFont,
            availableColors
          )
        );
        // Remove the used color from available colors
        availableColors.splice(
          availableColors.indexOf(this.lifeCharacters[i].color),
          1
        );
      }

      // Focus the input when game starts
      const input = document.getElementById("korean-input") as HTMLInputElement;
      const startButton = document.getElementById("start-button");
      if (input) {
        input.focus({ preventScroll: true });
      }
      if (startButton) {
        startButton.classList.add("active");
      }
    }

    private playNextGameMusicTrack(): void {
      if (!this.sounds.gameMusic || this.sounds.gameMusic.length === 0) return;

      // Stop current track if it's playing
      if (this.sounds.gameMusic[this.currentGameMusicIndex]) {
        this.sounds.gameMusic[this.currentGameMusicIndex].stop();
      }

      // Play next track
      this.playSound(this.sounds.gameMusic[this.currentGameMusicIndex], {
        volume: 0.08,
      });

      // Set up event listener for when this track ends
      this.sounds.gameMusic[this.currentGameMusicIndex].onended = () => {
        // Move to next track
        this.currentGameMusicIndex =
          (this.currentGameMusicIndex + 1) % this.sounds.gameMusic.length;
        // Play the next track
        this.playNextGameMusicTrack();
      };
    }

    gameOver(): void {
      this.isPlaying = false;
      this.isPaused = false;

      // Stop current game music track
      if (
        this.sounds.gameMusic &&
        this.sounds.gameMusic[this.currentGameMusicIndex]
      ) {
        this.sounds.gameMusic[this.currentGameMusicIndex].stop();
      }

      // Play game over sound
      if (this.sounds.gameOver) {
        this.playSound(this.sounds.gameOver, { rate: 0.5, volume: 0.1 }).then(
          () => {
            // After game over sound finishes, play the game over song
            if (this.sounds.gameOverSong) {
              this.playSound(this.sounds.gameOverSong, {
                volume: 0.1,
                loop: true,
                delay: 1,
              });
            }
          }
        );
      }

      // Create explosions for all remaining falling characters simultaneously
      this.fallingChars.forEach((char) => {
        this.createExplosion(char.x, char.y, char.char, false);
      });

      // Clear falling chars immediately since we don't need to wait for staggered explosions
      this.fallingChars.forEach((char) => {
        char.toDelete = true;
      });
      this.fallingChars = [];

      this.lastTypedChar = null;
      const startButton = document.getElementById("start-button");
      if (startButton) {
        startButton.classList.remove("active");
      }
    }

    private calculateDifficulty(): void {
      const gameTime = this.p.millis() - this.gameStartTime;
      const minutes = gameTime / 60000; // Convert to minutes

      // Gradually increase speed based on time
      this.speed = Math.min(this.maxSpeed, this.initialSpeed + minutes * 0.5);

      // Gradually increase max active characters
      this.maxActiveChars = Math.min(5, 1 + Math.floor(minutes));

      // Calculate current spawn interval
      const spawnIntervalDecrease = Math.min(
        this.initialSpawnInterval - this.minSpawnInterval,
        minutes * 500
      );
      this.initialSpawnInterval = Math.max(
        this.initialSpawnInterval - spawnIntervalDecrease,
        this.minSpawnInterval
      );
    }

    createExplosion(
      x: number,
      y: number,
      char: string,
      isSuccess: boolean = false
    ): void {
      // Create more particles for a denser explosion effect
      const numParticles = 20;
      for (let i = 0; i < numParticles; i++) {
        this.particles.push(
          new Particle(x, y, char, this.koreanPixelFont, isSuccess)
        );
      }
      if (isSuccess) {
        // Play random success sound
        const randomIndex = Math.floor(
          Math.random() * this.sounds.success.length
        );
        const successSound = this.sounds.success[randomIndex];
        if (successSound) {
          this.playSound(successSound, { rate: 1.2, volume: 0.1 });
        }
      } else {
        // Play random failure explosion sound
        const randomIndex =
          Math.floor(Math.random() * (this.sounds.explosions.length - 1)) + 1;
        const failureSound = this.sounds.explosions[randomIndex];
        if (failureSound) {
          this.playSound(failureSound, { rate: 1.3, volume: 0.08 });
        }
      }
    }

    update(): void {
      // Update power state
      this.updatePowerState();

      // Update start text opacity for pulsing effect
      this.startTextOpacity += 0.05 * this.startTextFading;
      if (this.startTextOpacity >= 1) {
        this.startTextFading = -1;
      } else if (this.startTextOpacity <= 0.3) {
        this.startTextFading = 1;
      }

      // Don't update game state if powered off
      if (!this.isPowered) return;

      // Rest of the update logic...

      // Update pause text opacity for flashing effect
      if (this.isPaused) {
        this.pauseTextOpacity += 0.03 * this.pauseTextFading;
        if (this.pauseTextOpacity >= 1) {
          this.pauseTextFading = -1;
        } else if (this.pauseTextOpacity <= 0.3) {
          this.pauseTextFading = 1;
        }
      }

      // Don't update game state if paused
      if (this.isPaused) return;

      if (this.isPlaying) {
        this.calculateDifficulty();

        // Add new falling characters based on current difficulty
        const currentTime = this.p.millis();
        if (
          this.fallingChars.length < this.maxActiveChars &&
          currentTime - this.lastSpawnTime >= this.initialSpawnInterval
        ) {
          const char =
            HANGUL_CHARS[Math.floor(this.p.random(HANGUL_CHARS.length))];
          const column = Math.floor(this.p.random(this.numColumns));
          const x = column * this.columnWidth + this.columnWidth / 2;
          this.fallingChars.push(
            new FallingChar(x, char, this.speed, this.koreanPixelFont, this.p)
          );
          this.lastSpawnTime = currentTime;
        }

        // Update life characters
        this.lifeCharacters.forEach((char) => char.update(this.p, currentTime));
      }

      // Update falling characters and handle life loss
      this.fallingChars = this.fallingChars.filter((char) => {
        char.update();
        if (char.y >= this.p.height || char.toDelete) {
          if (!char.isBackground) {
            if (this.isPlaying) {
              // Only count as a miss if the character hit the bottom (not a successful hit)
              if (char.y >= this.p.height && !char.wasSuccessfullyHit) {
                // Set the lost character for the current life
                if (
                  this.lives > 0 &&
                  this.lives <= this.lifeCharacters.length
                ) {
                  this.lifeCharacters[this.lives - 1].setLostChar(char.char);
                }
                this.lives--;
                if (this.lives <= 0) {
                  this.gameOver();
                }
                this.startFlashEffect();
              }
              // Create explosion for both successful hits and misses
              if (!char.wasSuccessfullyHit) {
                this.createExplosion(char.x, char.y, char.char, false);
              }
            }
          }
          return false;
        }
        return true;
      });

      // Update and filter particles
      this.particles = this.particles.filter((particle) => particle.update());

      // Background characters
      // Initialize column tracking if not already done
      if (this.columnLastY.length !== this.numColumns) {
        this.columnLastY = new Array(this.numColumns).fill(
          -this.minBackgroundSpacing
        );
      }

      // Add new background characters with spacing check
      for (let col = 0; col < this.numColumns; col++) {
        if (this.p.random(1) < 0.01) {
          // Check if there's enough space in this column
          const lastY = this.columnLastY[col];
          const existingCharsInColumn = this.backgroundChars.filter(
            (char) =>
              Math.abs(
                char.x - (col * this.columnWidth + this.columnWidth / 2)
              ) < 1
          );

          const nearestCharY = existingCharsInColumn.reduce((nearest, char) => {
            return char.y < 0 && char.y > nearest ? char.y : nearest;
          }, -Infinity);

          if (
            nearestCharY === -Infinity ||
            nearestCharY < -this.minBackgroundSpacing
          ) {
            const char =
              HANGUL_CHARS[Math.floor(this.p.random(HANGUL_CHARS.length))];
            const x = col * this.columnWidth + this.columnWidth / 2;
            this.backgroundChars.push(
              new FallingChar(x, char, 0.5, this.koreanPixelFont, this.p, true)
            );
            this.columnLastY[col] = -30; // Update last Y position for this column
          }
        }
      }

      // Update background characters and their column positions
      this.backgroundChars = this.backgroundChars.filter((char) => {
        char.update();
        // Update column tracking
        const col = Math.floor(char.x / this.columnWidth);
        if (col >= 0 && col < this.numColumns) {
          this.columnLastY[col] = Math.max(this.columnLastY[col], char.y);
        }
        return char.y < this.p.height + 30; // Allow characters to go slightly below screen before being removed
      });

      // Update flash effect
      if (this.isFlashing) {
        const elapsed = this.p.millis() - this.flashStartTime;
        if (elapsed >= this.flashDuration) {
          this.isFlashing = false;
        }
      }
    }

    draw(): void {
      this.p.background(0);

      // Handle screen power transition
      if (this.screenPowerTransitionStart > 0) {
        const elapsed = this.p.millis() - this.screenPowerTransitionStart;
        const progress = Math.min(
          1,
          elapsed / this.screenPowerTransitionDuration
        );

        if (this.isPowered) {
          // Power on transition
          const brightness = this.p.map(progress, 0, 1, 0, 255);
          this.p.fill(0, 0, 0, 255 - brightness);
          this.p.rect(0, 0, this.p.width, this.p.height);
        } else {
          // Power off transition
          const brightness = this.p.map(progress, 0, 1, 255, 0);
          this.p.fill(0, 0, 0, brightness);
          this.p.rect(0, 0, this.p.width, this.p.height);
        }
      }

      // Don't draw game content if powered off
      if (!this.isPowered) return;

      // Rest of the draw logic...

      // Create CRT-style radial background with flash effect
      const centerX = this.p.width / 2;
      const centerY = this.p.height / 2;
      const maxDist = Math.sqrt(
        Math.pow(this.p.width / 2, 2) + Math.pow(this.p.height / 2, 2)
      );

      for (let i = 0; i < 4; i++) {
        const gradient = this.p.drawingContext.createRadialGradient(
          centerX,
          centerY,
          0,
          centerX,
          centerY,
          maxDist * (1.4 - i * 0.15)
        );

        if (this.isFlashing) {
          const elapsed = this.p.millis() - this.flashStartTime;
          const flashProgress =
            (elapsed % (this.flashDuration / this.maxFlashCount)) /
            (this.flashDuration / this.maxFlashCount);
          const flashIntensity = Math.sin(flashProgress * Math.PI);

          if (i === 0) {
            gradient.addColorStop(
              0,
              `rgba(${192 + 63 * flashIntensity}, ${0}, ${0}, 0.25)`
            );
            gradient.addColorStop(
              0.85,
              `rgba(${64 + 63 * flashIntensity}, ${0}, ${0}, 0.15)`
            );
            gradient.addColorStop(1, "rgba(0, 0, 0, 0.3)");
          } else {
            gradient.addColorStop(
              0,
              `rgba(${192 + 63 * flashIntensity}, ${0}, ${0}, 0.06)`
            );
            gradient.addColorStop(
              0.85,
              `rgba(${64 + 63 * flashIntensity}, ${0}, ${0}, 0.03)`
            );
            gradient.addColorStop(1, "rgba(0, 0, 0, 0.08)");
          }
        } else {
          if (i === 0) {
            gradient.addColorStop(0, "rgba(96, 0, 192, 0.25)");
            gradient.addColorStop(0.85, "rgba(32, 0, 64, 0.15)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0.3)");
          } else {
            gradient.addColorStop(0, "rgba(96, 0, 192, 0.06)");
            gradient.addColorStop(0.85, "rgba(32, 0, 64, 0.03)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0.08)");
          }
        }

        this.p.drawingContext.fillStyle = gradient;
        this.p.noStroke();

        // Create bulge effect by using ellipse with larger bulge
        const bulgeAmount = 1.2 - i * 0.015;
        this.p.ellipse(
          centerX,
          centerY,
          this.p.width * bulgeAmount,
          this.p.height * bulgeAmount
        );
      }

      // Draw background characters
      this.backgroundChars.forEach((char) => char.draw(this.p));

      // Draw falling characters
      this.fallingChars.forEach((char) => char.draw(this.p));

      // Draw particles
      this.particles.forEach((particle) => particle.draw(this.p));

      // Draw score and lives
      if (this.isPlaying) {
        this.p.push();
        this.p.textFont(this.pixelFont);

        // Draw score on bottom left
        this.p.textAlign(this.p.LEFT, this.p.BOTTOM);
        this.p.textSize(16);

        // Calculate score color based on transition
        let currentScoreColor = this.scoreColor;
        if (this.scoreColorTransitionStart > 0) {
          const elapsed = this.p.millis() - this.scoreColorTransitionStart;
          const progress = Math.min(
            1,
            elapsed / this.scoreColorTransitionDuration
          );

          if (progress < 1) {
            // Interpolate between red and normal color
            const normalColor = this.p.color("#00ff00"); // Use green as normal color
            const redColor = this.p.color("#FF0000");
            currentScoreColor = this.p.lerpColor(
              redColor,
              normalColor,
              progress
            );
          } else {
            this.scoreColorTransitionStart = 0;
            currentScoreColor = this.p.color("#00ff00");
          }
        }

        // Score outer glow
        this.p.fill(currentScoreColor);
        this.p.fill(
          this.p.red(currentScoreColor),
          this.p.green(currentScoreColor),
          this.p.blue(currentScoreColor),
          100
        );
        this.p.text(`SCORE ${this.score}`, 25, this.p.height - 20);

        // Score middle glow
        this.p.fill(
          this.p.red(currentScoreColor),
          this.p.green(currentScoreColor),
          this.p.blue(currentScoreColor),
          150
        );
        this.p.text(`SCORE ${this.score}`, 25, this.p.height - 20);

        // Score inner text
        this.p.fill(
          this.p.red(currentScoreColor),
          this.p.green(currentScoreColor),
          this.p.blue(currentScoreColor),
          255
        );
        this.p.text(`SCORE ${this.score}`, 25, this.p.height - 20);

        // Draw score animations
        this.scoreAnimations = this.scoreAnimations.filter((animation) => {
          const isActive = animation.update();
          if (isActive) {
            animation.draw(this.p, this.pixelFont);
          }
          return isActive;
        });

        // Draw lives as Korean characters
        this.lifeCharacters.forEach((char) => char.draw(this.p));

        this.p.pop();

        // Draw pause overlay if paused
        if (this.isPlaying && this.isPaused) {
          this.p.push();

          // Semi-transparent background
          this.p.fill(0, 0, 0, 100);
          this.p.rect(0, 0, this.p.width, this.p.height);

          // Draw pause text in Korean with colors and wave effect
          this.p.textAlign(this.p.CENTER, this.p.CENTER);
          this.p.textSize(60);
          this.p.textFont(this.koreanPixelFont); // Use koreanPixelFont for Korean pause text
          this.p.textStyle(this.p.BOLD);

          const pauseText = "일시정지";
          const colors = [
            "#FF6B6B", // Pink/Red
            "#4ECDC4", // Teal
            "#45B7D1", // Light Blue
            "#96CEB4", // Sage
          ];

          // Calculate total width of text for centering
          const totalWidth = pauseText
            .split("")
            .reduce((width, char) => width + this.p.textWidth(char), 0);
          let currentX = this.p.width / 2 - totalWidth / 2 + 20;

          // Draw each character with animation
          pauseText.split("").forEach((char, i) => {
            const color = colors[i % colors.length];
            const yOffset = Math.sin(this.p.millis() / 600 + i * 0.5) * 20;

            // Outer glow
            const rgb = this.p.color(color);
            this.p.fill(color + "99"); // Reduce to 60% alpha
            for (let offset = 3; offset >= 1; offset--) {
              this.p.text(char, currentX, this.p.height / 2 + yOffset - offset);
              this.p.text(char, currentX, this.p.height / 2 + yOffset + offset);
              this.p.text(char, currentX - offset, this.p.height / 2 + yOffset);
              this.p.text(char, currentX + offset, this.p.height / 2 + yOffset);
            }

            // Main character
            this.p.fill(255, 255, 255);
            this.p.text(char, currentX, this.p.height / 2 + yOffset);
            this.p.fill(color + "FF");
            this.p.text(char, currentX, this.p.height / 2 + yOffset);

            currentX += this.p.textWidth(char) + 5; // Add small spacing between characters
          });

          // Subtitle with flashing effect and special glow for button text
          this.p.textSize(20);
          this.p.textFont(this.pixelFont);
          this.p.textAlign(this.p.CENTER, this.p.CENTER);

          const pressText = "PRESS ";
          const buttonText = "시작";
          const toResumeText = " TO RESUME";

          // Calculate total width for centering
          const resumeTextWidth = this.p.textWidth(
            pressText + buttonText + toResumeText
          );
          const startX = this.p.width / 2 - resumeTextWidth / 2;

          this.p.textAlign(this.p.LEFT, this.p.CENTER);

          // Increased spacing by moving the subtitle down a bit more
          const subtitleY = this.p.height / 2 + 80; // Increased from 60 to 80

          // Draw "PRESS" with normal opacity
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 255);
          this.p.text(pressText, startX, subtitleY);

          // Draw button text with arcade button glow effect
          const buttonX = startX + this.p.textWidth(pressText);

          // Use Arial for Korean button text
          this.p.textFont("Arial");
          this.p.textStyle(this.p.BOLD);

          // Calculate button dimensions
          const buttonPadding = 10;
          const buttonHeight = 30;
          const buttonWidth = this.p.textWidth(buttonText) + buttonPadding * 2;
          const buttonY = subtitleY - buttonHeight / 2;

          // Draw button base (shadow)
          this.p.fill(44, 132, 76, this.pauseTextOpacity * 255); // Darker green
          this.p.noStroke();
          this.p.rect(buttonX, buttonY + 4, buttonWidth, buttonHeight, 6);

          // Draw button surface
          this.p.fill(74, 222, 128, this.pauseTextOpacity * 255); // Light green
          this.p.rect(buttonX, buttonY, buttonWidth, buttonHeight, 6);

          // Add highlight to button
          const gradientHeight = buttonHeight * 0.4;
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 40);
          this.p.rect(
            buttonX,
            buttonY,
            buttonWidth,
            gradientHeight,
            6,
            6,
            0,
            0
          );

          // Outer button glow
          this.p.fill(74, 222, 128, this.pauseTextOpacity * 80); // Light green glow
          for (let offset = 2; offset >= 1; offset--) {
            this.p.text(
              buttonText,
              buttonX + buttonPadding - offset,
              buttonY + buttonHeight / 2 + 4 - offset
            );
            this.p.text(
              buttonText,
              buttonX + buttonPadding + offset,
              buttonY + buttonHeight / 2 + 4 + offset
            );
          }

          // Inner button text
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 255);
          this.p.text(
            buttonText,
            buttonX + buttonPadding,
            buttonY + buttonHeight / 2
          );

          // Draw "TO RESUME" with normal opacity
          this.p.textFont(this.pixelFont);
          this.p.fill(255, 255, 255, this.pauseTextOpacity * 255);
          this.p.text(toResumeText, buttonX + buttonWidth + 5, subtitleY);

          this.p.pop();
        }
      }

      // Draw start/game over text
      if (!this.isPlaying) {
        this.p.push();
        this.p.textAlign(this.p.CENTER, this.p.CENTER);

        // Draw title text with wave animation
        const titleText = this.lives <= 0 ? "GAME OVER" : "한글 HERO";
        const colors = [
          "#FF6B6B", // Pink/Red
          "#4ECDC4", // Teal
          "#45B7D1", // Light Blue
          "#96CEB4", // Sage
          "#FFEEAD", // Light Yellow
          "#D4A5A5", // Light Pink
        ];

        if (this.lives <= 0) {
          // Game Over text
          this.p.textSize(40);
          this.p.textFont(this.pixelFont);

          // Draw text glow
          const glowColor = this.p.color("#ff0066");
          glowColor.setAlpha(this.startTextOpacity * 100);
          this.p.fill(glowColor);
          this.p.textSize(42);
          this.p.text(titleText, this.p.width / 2, this.p.height / 2 - 20);

          // Draw main text
          this.p.fill(255, 255, 255, this.startTextOpacity * 255);
          this.p.textSize(40);
          this.p.text(titleText, this.p.width / 2, this.p.height / 2 - 20);
        } else {
          // 한글 HERO title with wave animation
          this.p.textSize(60);

          // Calculate total width for centering
          const chars = titleText.split("");
          let totalWidth = 0;
          chars.forEach((char) => {
            if (isHangul(char)) {
              this.p.textFont("Arial");
            } else {
              this.p.textFont(this.pixelFont);
            }
            totalWidth += this.p.textWidth(char) + 5; // Account for spacing in width calculation
          });

          let currentX = this.p.width / 2 - totalWidth / 2;

          // Draw each character with animation
          chars.forEach((char, i) => {
            const color = colors[i % colors.length];
            const yOffset = Math.sin(this.p.millis() / 600 + i * 0.5) * 20;
            const xOffset = isHangul(char) ? 60 : 26;

            if (isHangul(char)) {
              this.p.textFont("Arial");
            } else {
              this.p.textFont(this.pixelFont);
            }

            // Outer glow
            this.p.fill(color + "99");
            for (let offset = 3; offset >= 1; offset--) {
              this.p.text(
                char,
                currentX + xOffset,
                this.p.height / 2 - 20 + yOffset - offset
              );
              this.p.text(
                char,
                currentX + xOffset,
                this.p.height / 2 - 20 + yOffset + offset
              );
              this.p.text(
                char,
                currentX + xOffset - offset,
                this.p.height / 2 - 20 + yOffset
              );
              this.p.text(
                char,
                currentX + xOffset + offset,
                this.p.height / 2 - 20 + yOffset
              );
            }

            // Main character
            this.p.fill(255, 255, 255);
            this.p.text(
              char,
              currentX + xOffset,
              this.p.height / 2 - 20 + yOffset
            );
            this.p.fill(color + "FF");
            this.p.text(
              char,
              currentX + xOffset,
              this.p.height / 2 - 20 + yOffset
            );

            currentX += this.p.textWidth(char) + 5; // Add small spacing between characters
          });
        }

        // Draw subtitle with button reference
        this.p.textSize(20);
        this.p.textAlign(this.p.CENTER, this.p.CENTER);

        const pressText = "PRESS ";
        const buttonText = "시작";
        const toStartText = this.lives <= 0 ? " TO TRY AGAIN" : " TO PLAY";

        // Calculate total width for centering
        const startTextWidth = this.p.textWidth(
          pressText + buttonText + toStartText
        );
        const startX = this.p.width / 2 - startTextWidth / 2;

        this.p.textAlign(this.p.LEFT, this.p.CENTER);

        // Draw "PRESS" with normal opacity
        this.p.fill(255, 255, 255, this.startTextOpacity * 255);
        this.p.text(pressText, startX, this.p.height / 2 + 90);

        // Draw button text with arcade button glow effect
        const buttonX = startX + this.p.textWidth(pressText);

        // Use Arial for Korean button text
        this.p.textFont("Arial");
        this.p.textStyle(this.p.BOLD);

        // Calculate button dimensions
        const buttonPadding = 10;
        const buttonHeight = 30;
        const buttonWidth = this.p.textWidth(buttonText) + buttonPadding * 2;
        const buttonY = this.p.height / 2 + 90 - buttonHeight / 2;

        // Draw button base (shadow)
        this.p.fill(44, 132, 76, this.startTextOpacity * 255);
        this.p.noStroke();
        this.p.rect(buttonX, buttonY + 4, buttonWidth, buttonHeight, 6);

        // Draw button surface
        this.p.fill(74, 222, 128, this.startTextOpacity * 255);
        this.p.rect(buttonX, buttonY, buttonWidth, buttonHeight, 6);

        // Add highlight to button
        const gradientHeight = buttonHeight * 0.4;
        this.p.fill(255, 255, 255, this.startTextOpacity * 40);
        this.p.rect(buttonX, buttonY, buttonWidth, gradientHeight, 6, 6, 0, 0);

        // Outer button glow
        this.p.fill(74, 222, 128, this.startTextOpacity * 80);
        for (let offset = 2; offset >= 1; offset--) {
          this.p.text(
            buttonText,
            buttonX + buttonPadding - offset,
            buttonY + buttonHeight / 2 + 4 - offset
          );
          this.p.text(
            buttonText,
            buttonX + buttonPadding + offset,
            buttonY + buttonHeight / 2 + 4 + offset
          );
        }

        // Inner button text
        this.p.fill(255, 255, 255, this.startTextOpacity * 255);
        this.p.text(
          buttonText,
          buttonX + buttonPadding,
          buttonY + buttonHeight / 2
        );

        // Draw "TO START/RESTART" with normal opacity
        this.p.textFont(this.pixelFont);
        this.p.fill(255, 255, 255, this.startTextOpacity * 255);
        this.p.text(
          toStartText,
          buttonX + buttonWidth + 5,
          this.p.height / 2 + 90
        );

        this.p.pop();
      }

      // Draw last typed character with enhanced arcade effect
      if (this.lastTypedChar && this.isPlaying && !this.isPaused) {
        const timeSinceTyped = this.p.millis() - this.lastTypedCharTime;
        const fadeTime = 1000;
        if (timeSinceTyped < fadeTime) {
          this.p.push();
          const baseSize = 50;
          this.p.textAlign(this.p.CENTER, this.p.CENTER);
          const opacity = this.p.map(timeSinceTyped, 0, fadeTime, 255, 0);

          // Use koreanPixelFont for Korean characters
          if (isHangul(this.lastTypedChar)) {
            this.p.textFont(this.koreanPixelFont);
            this.p.textStyle(this.p.BOLD);
          } else {
            this.p.textFont(this.pixelFont);
          }

          // Draw outer glow
          const glowColor = this.p.color(this.lastTypedCharColor);
          glowColor.setAlpha(opacity * 0.3);
          this.p.fill(glowColor);
          this.p.textSize(baseSize + 6);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          // Draw middle glow
          glowColor.setAlpha(opacity * 0.6);
          this.p.fill(glowColor);
          this.p.textSize(baseSize + 3);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          // Draw main character
          const c = this.p.color(this.lastTypedCharColor);
          c.setAlpha(opacity);
          this.p.fill(c);
          this.p.textSize(baseSize);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          // Draw inner highlight
          const highlightColor = this.p.color("#ffffff");
          highlightColor.setAlpha(opacity * 0.7);
          this.p.fill(highlightColor);
          this.p.textSize(baseSize * 0.9);
          this.p.text(this.lastTypedChar, this.p.width / 2, this.p.height - 50);

          this.p.pop();
        } else {
          this.lastTypedChar = null;
        }
      }

      // Draw warning messages
      this.warningMessages = this.warningMessages.filter((message) => {
        const isActive = message.update();
        if (isActive) {
          message.draw(this.p, this.pixelFont);
        }
        return isActive;
      });
    }

    handleKeyPress(key: string): void {
      if (!this.isPlaying) return;

      // Check if the key is an English character
      if (/^[a-zA-Z]$/.test(key)) {
        // Add warning message and pause the game
        this.warningMessages.push(
          new WarningMessage(this.p, "Enable the Korean keyboard to play")
        );
        if (!this.isPaused) {
          this.togglePause();
        }
        return;
      }

      // Don't process input if paused
      if (this.isPaused) return;

      const charIndex = this.fallingChars.findIndex(
        (char) =>
          char.char.toLowerCase() === key.toLowerCase() &&
          !char.isBackground &&
          !char.wasSuccessfullyHit
      );

      this.lastTypedChar = key;
      this.lastTypedCharTime = this.p.millis();

      if (charIndex !== -1) {
        // Matched a falling character - use neon colors for success
        this.lastTypedCharColor = "#00ff00";
        const matchedChar = this.fallingChars[charIndex];
        matchedChar.startGrowth(); // Start the growth animation
        matchedChar.wasSuccessfullyHit = true; // Mark as successfully hit
        this.score += 10;
        // If score was zero and we're adding points, transition back to green
        if (this.wasScoreZero) {
          this.scoreColor = this.p.color("#00ff00");
          this.wasScoreZero = false;
        }

        // Create success explosion
        setTimeout(() => {
          this.createExplosion(
            matchedChar.x,
            matchedChar.y,
            matchedChar.char,
            true
          );
        }, 100); // 50ms delay
      } else {
        // No match found - use hot pink for errors and reduce score
        this.lastTypedCharColor = "#ff0066";
        if (this.score > 0) {
          this.score = Math.max(0, this.score - 1);
          // Calculate position for score reduction animation
          const scoreText = `SCORE ${this.score}`;
          const scoreWidth = this.p.textWidth(scoreText);
          const numberStart = 25 + this.p.textWidth("SCORE "); // Position after "SCORE "
          const numberWidth = this.p.textWidth(this.score.toString());
          const centerOfNumber = numberStart + numberWidth / 2;

          // Add score reduction animation centered over the number
          this.scoreAnimations.push(
            new ScoreAnimation(centerOfNumber, this.p.height - 40, "-1")
          );

          // If score reaches zero, set it to red immediately and mark that it was due to point loss
          if (this.score === 0) {
            this.scoreColor = this.p.color("#FF0000");
            this.wasScoreZero = true;
            // Reset any ongoing color transition
            this.scoreColorTransitionStart = 0;
          } else {
            // Only start the color transition if we're not at zero
            this.scoreColorTransitionStart = this.p.millis();
          }
        }
      }
    }

    startFlashEffect(): void {
      this.isFlashing = true;
      this.flashStartTime = this.p.millis();
      this.flashCount = 0;
      // Set maxFlashCount based on how many mistakes were made (MAX_LIVES - current lives)
      this.maxFlashCount = Game.MAX_LIVES - this.lives;
      // Adjust flash duration based on number of flashes to keep consistent timing per flash
      this.flashDuration = this.maxFlashCount * 600; // 600ms per flash
    }

    // Add new power state methods
    public handlePowerToggle(): void {
      if (!this.isLongPress) {
        // Normal press - turn on if off, start game if on
        if (!this.isPowered) {
          this.turnOn();
        } else if (!this.isPlaying) {
          this.start();
        } else {
          this.togglePause();
        }
      } else {
        // Long press - turn off if on
        if (this.isPowered) {
          this.turnOff();
        }
      }
    }

    private turnOn(): void {
      this.isPowered = true;
      this.screenPowerTransitionStart = this.p.millis();
      // Play power on sound
      if (this.sounds.buttonPressed) {
        this.playSound(this.sounds.buttonPressed, { volume: 1.5, rate: 0.8 });
      }
      // Play intro music in a loop
      if (this.sounds.intro) {
        this.playSound(this.sounds.intro, { volume: 0.1, loop: true });
      }
      // Add powered class to LED housing and remove off class from button
      const ledHousing = document.querySelector(".led-housing");
      const startButton = document.getElementById("start-button");
      if (ledHousing) {
        ledHousing.classList.add("powered");
      }
      if (startButton) {
        startButton.classList.remove("off");
      }
    }

    private turnOff(): void {
      this.isPowered = false;
      this.isPlaying = false;
      this.isPaused = false;
      this.screenPowerTransitionStart = this.p.millis();

      // Stop intro music if it's playing
      if (this.sounds.intro) {
        this.sounds.intro.stop();
      }

      // Stop current game music track
      if (
        this.sounds.gameMusic &&
        this.sounds.gameMusic[this.currentGameMusicIndex]
      ) {
        this.sounds.gameMusic[this.currentGameMusicIndex].stop();
      }

      // Stop game over song if it's playing
      if (this.sounds.gameOverSong) {
        this.sounds.gameOverSong.stop();
      }

      // Reset game state
      this.score = 0;
      this.lives = Game.MAX_LIVES;
      this.fallingChars = [];
      this.backgroundChars = [];
      this.particles = [];
      this.scoreAnimations = [];
      this.speed = this.initialSpeed;
      this.lastTypedChar = null;
      this.lastTypedCharColor = "#FFFFFF";
      this.lastTypedCharTime = 0;
      this.startTextOpacity = 0;
      this.startTextFading = 1;
      this.pauseTextOpacity = 0.3;
      this.pauseTextFading = 1;
      this.scoreColor = this.p.color("#00ff00");
      this.scoreColorTransitionStart = 0;
      this.wasScoreZero = false;
      this.flashStartTime = 0;
      this.isFlashing = false;
      this.flashCount = 0;
      this.maxFlashCount = 1;
      this.lifeCharacters = [];
      this.columnLastY = new Array(this.numColumns).fill(
        -this.minBackgroundSpacing
      );
      this.gameStartTime = 0;
      this.lastSpawnTime = 0;
      this.initialSpawnInterval = 3000;
      this.maxActiveChars = 1;
      this.currentGameMusicIndex = 0; // Reset music index

      // Play power off sound
      if (this.sounds.buttonReleased) {
        this.playSound(this.sounds.buttonReleased, { volume: 1.5, rate: 0.8 });
      }
      // Remove powered class from LED housing and add off class to button
      const ledHousing = document.querySelector(".led-housing");
      const startButton = document.getElementById("start-button");
      if (ledHousing) {
        ledHousing.classList.remove("powered");
      }
      if (startButton) {
        startButton.classList.add("off");
      }
    }

    private updatePowerState(): void {
      // Update screen power transition
      if (this.screenPowerTransitionStart > 0) {
        const elapsed = this.p.millis() - this.screenPowerTransitionStart;
        const progress = Math.min(
          1,
          elapsed / this.screenPowerTransitionDuration
        );

        if (progress >= 1) {
          this.screenPowerTransitionStart = 0;
        }
      }
    }
  }

  // Initialize p5.js
  new p5((p: p5) => {
    let game: Game;
    let pixelFont: p5.Font;
    let koreanPixelFont: p5.Font;
    let buttonPressedSound: p5.SoundFile;
    let buttonReleasedSound: p5.SoundFile;
    let introMusic: p5.SoundFile;
    let gameOverSound: p5.SoundFile;
    let explosions: p5.SoundFile[];
    let gameMusic: p5.SoundFile[]; // Changed to array
    let gameOverSong: p5.SoundFile;
    let currentGameMusicIndex: number = 0; // Add index tracking
    const container = document.getElementById("game-container");
    if (!container) return;

    p.preload = () => {
      pixelFont = p.loadFont("/fonts/PressStart2P-Regular.ttf");
      koreanPixelFont = p.loadFont("/fonts/UnifontExMono.ttf");
      buttonPressedSound = p.loadSound("/sounds/button-pressed.mp3");
      buttonReleasedSound = p.loadSound("/sounds/button-depressed.mp3");
      introMusic = p.loadSound("/sounds/hangul-hero-intro.mp3");
      gameOverSound = p.loadSound("/sounds/game-over.mp3");
      gameOverSong = p.loadSound("/sounds/game-over-song.mp3");

      // Load all game music tracks
      gameMusic = [
        p.loadSound("/sounds/game-music-1.mp3"),
        p.loadSound("/sounds/game-music-2.mp3"),
        p.loadSound("/sounds/game-music-3.mp3"),
        p.loadSound("/sounds/game-music-4.mp3"),
      ];

      // Load explosion sounds
      explosions = [
        p.loadSound("/sounds/explosion-1.mp3"),
        p.loadSound("/sounds/explosion-2.mp3"),
        p.loadSound("/sounds/explosion-3.mp3"),
      ];

      // Load success sounds
      const successSounds = [
        p.loadSound("/sounds/success-1.mp3"),
        p.loadSound("/sounds/success-2.mp3"),
        p.loadSound("/sounds/success-3.mp3"),
      ];

      game = new Game(p, pixelFont, koreanPixelFont, {
        explosions: explosions,
        buttonPressed: buttonPressedSound,
        buttonReleased: buttonReleasedSound,
        gameOver: gameOverSound,
        intro: introMusic,
        success: successSounds,
        gameMusic: gameMusic,
        gameOverSong: gameOverSong,
      });
    };

    p.setup = () => {
      const canvas = p.createCanvas(
        container.clientWidth,
        container.clientWidth * 0.75
      );
      canvas.parent(container);
      game.numColumns = Math.floor(p.width / game.columnWidth);
      p.textFont(pixelFont);

      // Setup input handling
      game.setupInput();

      // Setup start button with power state handling
      const startButton = document.getElementById("start-button");
      if (startButton) {
        startButton.addEventListener("mousedown", async () => {
          game.buttonPressStartTime = Date.now();
          await game.playSound(game.sounds.buttonPressed, {
            volume: 1.5,
            rate: 0.8,
          });
        });

        startButton.addEventListener("mouseup", async () => {
          const pressDuration = Date.now() - game.buttonPressStartTime;
          game.isLongPress = pressDuration >= game.longPressThreshold;
          game.handlePowerToggle();
          await game.playSound(game.sounds.buttonReleased, {
            volume: 1.5,
            rate: 0.8,
          });
        });

        // Handle long press
        let longPressTimer: NodeJS.Timeout;
        startButton.addEventListener("mousedown", () => {
          longPressTimer = setTimeout(() => {
            game.isLongPress = true;
            game.handlePowerToggle();
          }, game.longPressThreshold);
        });

        startButton.addEventListener("mouseup", () => {
          clearTimeout(longPressTimer);
        });
      }
    };

    p.draw = () => {
      game.update();
      game.draw();
    };

    // Handle window resize
    p.windowResized = () => {
      p.resizeCanvas(container.clientWidth, container.clientWidth * 0.75);
      game.numColumns = Math.floor(p.width / game.columnWidth);
    };
  });
</script>
